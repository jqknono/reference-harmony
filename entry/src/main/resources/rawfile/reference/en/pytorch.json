{
  "id": "pytorch",
  "name": "PyTorch",
  "title": "This is a quick reference list of cheat sheets for PyTorch. See also [PyTorch website](https://pytorch.org/)",
  "icon": "https://raw.githubusercontent.com/Fechin/reference/main/source/assets/icon/pytorch.svg",
  "sections": [
    {
      "id": "intro",
      "title": "Intro",
      "startIndex": 0
    },
    {
      "id": "s1",
      "title": "Imports",
      "startIndex": 1
    },
    {
      "id": "s2",
      "title": "Tensors",
      "startIndex": 7
    },
    {
      "id": "s3",
      "title": "Data Utilities",
      "startIndex": 16
    }
  ],
  "cards": [
    {
      "id": "intro-0",
      "sectionId": "intro",
      "title": "Intro",
      "body": "This is a quick reference list of cheat sheets for PyTorch. See also [PyTorch website](https://pytorch.org/)"
    },
    {
      "id": "s1-1",
      "sectionId": "s1",
      "title": "General",
      "body": "```\nimport torch                                        # root package\nfrom torch.utils.data import Dataset, DataLoader    # dataset representation and loading\n```"
    },
    {
      "id": "s1-2",
      "sectionId": "s1",
      "title": "Neural Network API",
      "body": "```\nimport torch.autograd as autograd         # computation graph\nfrom torch import Tensor                  # tensor node in the computation graph\nimport torch.nn as nn                     # neural networks\nimport torch.nn.functional as F           # layers, activations and more\nimport torch.optim as optim               # optimizers e.g. gradient descent, ADAM, etc.\nfrom torch.jit import script, trace       # hybrid frontend decorator and tracing jit\n```"
    },
    {
      "id": "s1-3",
      "sectionId": "s1",
      "title": "Torchscript and JIT",
      "body": "```\ntorch.jit.trace()         # takes your module or function and an example\n                          # data input, and traces the computational steps\n                          # that the data encounters as it progresses through the model\n\n@script                   # decorator used to indicate data-dependent\n                          # control flow within the code being traced\n```"
    },
    {
      "id": "s1-4",
      "sectionId": "s1",
      "title": "ONNX",
      "body": "%60%60%60%0Atorch.onnx.export(model%2C%20dummy%20data%2C%20xxxx.proto)%20%20%20%20%20%20%20%23%20exports%20an%20ONNX%20formatted%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20model%20using%20a%20trained%20model%2C%20dummy%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20data%20and%20the%20desired%20file%20name%0A%0Amodel%20%3D%20onnx.load(%22alexnet.proto%22)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20load%20an%20ONNX%20model%0Aonnx.checker.check_model(model)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20check%20that%20the%20model%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20IR%20is%20well%20formed%0A%0Aonnx.helper.printable_graph(model.graph)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20print%20a%20human%20readable%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20representation%20of%20the%20graph%0A%60%60%60",
      "encoded": true
    },
    {
      "id": "s1-5",
      "sectionId": "s1",
      "title": "Vision",
      "body": "```\nfrom torchvision import datasets, models, transforms     # vision datasets,\n                                                         # architectures &\n                                                         # transforms\n\nimport torchvision.transforms as transforms              # composable transforms\n```"
    },
    {
      "id": "s1-6",
      "sectionId": "s1",
      "title": "Distributed Training",
      "body": "```\nimport torch.distributed as dist             # distributed communication\nfrom torch.multiprocessing import Process    # memory sharing processes\n```"
    },
    {
      "id": "s2-7",
      "sectionId": "s2",
      "title": "Creation",
      "body": "%60%60%60%0Ax%20%3D%20torch.randn(*size)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20tensor%20with%20independent%20N(0%2C1)%20entries%0Ax%20%3D%20torch.%5Bones%7Czeros%5D(*size)%20%20%20%20%20%20%20%23%20tensor%20with%20all%201's%20%5Bor%200's%5D%0Ax%20%3D%20torch.tensor(L)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20create%20tensor%20from%20%5Bnested%5D%20list%20or%20ndarray%20L%0Ay%20%3D%20x.clone()%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20clone%20of%20x%0Awith%20torch.no_grad()%3A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20code%20wrap%20that%20stops%20autograd%20from%20tracking%20tensor%20history%0Arequires_grad%3DTrue%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20arg%2C%20when%20set%20to%20True%2C%20tracks%20computation%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20history%20for%20future%20derivative%20calculations%0A%60%60%60",
      "encoded": true
    },
    {
      "id": "s2-8",
      "sectionId": "s2",
      "title": "Dimensionality",
      "body": "```\nx.size()                                  # return tuple-like object of dimensions\nx = torch.cat(tensor_seq, dim=0)          # concatenates tensors along dim\ny = x.view(a,b,...)                       # reshapes x into size (a,b,...)\ny = x.view(-1,a)                          # reshapes x into size (b,a) for some b\ny = x.transpose(a,b)                      # swaps dimensions a and b\ny = x.permute(*dims)                      # permutes dimensions\ny = x.unsqueeze(dim)                      # tensor with added axis\ny = x.unsqueeze(dim=2)                    # (a,b,c) tensor -> (a,b,1,c) tensor\ny = x.squeeze()                           # removes all dimensions of size 1 (a,1,b,1) -> (a,b)\ny = x.squeeze(dim=1)                      # removes specified dimension of size 1 (a,1,b,1) -> (a,b,1)\n```"
    },
    {
      "id": "s2-9",
      "sectionId": "s2",
      "title": "Algebra",
      "body": "```\nret = A.mm(B)       # matrix multiplication\nret = A.mv(x)       # matrix-vector multiplication\nx = x.t()           # matrix transpose\n```"
    },
    {
      "id": "s2-10",
      "sectionId": "s2",
      "title": "GPU%20Usage",
      "body": "%60%60%60%0Atorch.cuda.is_available%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20check%20for%20cuda%0Ax%20%3D%20x.cuda()%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20move%20x's%20data%20from%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20CPU%20to%20GPU%20and%20return%20new%20object%0A%0Ax%20%3D%20x.cpu()%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20move%20x's%20data%20from%20GPU%20to%20CPU%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20and%20return%20new%20object%0A%0Aif%20not%20args.disable_cuda%20and%20torch.cuda.is_available()%3A%20%20%20%20%20%23%20device%20agnostic%20code%0A%20%20%20%20args.device%20%3D%20torch.device('cuda')%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20and%20modularity%0Aelse%3A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%0A%20%20%20%20args.device%20%3D%20torch.device('cpu')%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%0A%0Anet.to(device)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20recursively%20convert%20their%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20parameters%20and%20buffers%20to%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20device%20specific%20tensors%0A%0Ax%20%3D%20x.to(device)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20copy%20your%20tensors%20to%20a%20device%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20(gpu%2C%20cpu)%0A%60%60%60",
      "encoded": true
    },
    {
      "id": "s2-11",
      "sectionId": "s2",
      "title": "Deep Learning",
      "body": "```\nnn.Linear(m,n)                                # fully connected layer from\n                                              # m to n units\n\nnn.ConvXd(m,n,s)                              # X dimensional conv layer from\n                                              # m to n channels where X‚ç∑{1,2,3}\n                                              # and the kernel size is s\n\nnn.MaxPoolXd(s)                               # X dimension pooling layer\n                                              # (notation as above)\n\nnn.BatchNormXd                                # batch norm layer\nnn.RNN/LSTM/GRU                               # recurrent layers\nnn.Dropout(p=0.5, inplace=False)              # dropout layer for any dimensional input\nnn.Dropout2d(p=0.5, inplace=False)            # 2-dimensional channel-wise dropout\nnn.Embedding(num_embeddings, embedding_dim)   # (tensor-wise) mapping from\n                                              # indices to embedding vectors\n```"
    },
    {
      "id": "s2-12",
      "sectionId": "s2",
      "title": "Loss Functions",
      "body": "```\nnn.X                                  # where X is L1Loss, MSELoss, CrossEntropyLoss\n                                      # CTCLoss, NLLLoss, PoissonNLLLoss,\n                                      # KLDivLoss, BCELoss, BCEWithLogitsLoss,\n                                      # MarginRankingLoss, HingeEmbeddingLoss,\n                                      # MultiLabelMarginLoss, SmoothL1Loss,\n                                      # SoftMarginLoss, MultiLabelSoftMarginLoss,\n                                      # CosineEmbeddingLoss, MultiMarginLoss,\n                                      # or TripletMarginLoss\n```"
    },
    {
      "id": "s2-13",
      "sectionId": "s2",
      "title": "Activation Functions",
      "body": "```\nnn.X                                  # where X is ReLU, ReLU6, ELU, SELU, PReLU, LeakyReLU,\n                                      # RReLu, CELU, GELU, Threshold, Hardshrink, HardTanh,\n                                      # Sigmoid, LogSigmoid, Softplus, SoftShrink,\n                                      # Softsign, Tanh, TanhShrink, Softmin, Softmax,\n                                      # Softmax2d, LogSoftmax or AdaptiveSoftmaxWithLoss\n```"
    },
    {
      "id": "s2-14",
      "sectionId": "s2",
      "title": "Optimizers",
      "body": "```\nopt = optim.x(model.parameters(), ...)      # create optimizer\nopt.step()                                  # update weights\noptim.X                                     # where X is SGD, Adadelta, Adagrad, Adam,\n                                            # AdamW, SparseAdam, Adamax, ASGD,\n                                            # LBFGS, RMSprop or Rprop\n```"
    },
    {
      "id": "s2-15",
      "sectionId": "s2",
      "title": "Learning rate scheduling",
      "body": "```\nscheduler = optim.X(optimizer,...)      # create lr scheduler\nscheduler.step()                        # update lr after optimizer updates weights\noptim.lr_scheduler.X                    # where X is LambdaLR, MultiplicativeLR,\n                                        # StepLR, MultiStepLR, ExponentialLR,\n                                        # CosineAnnealingLR, ReduceLROnPlateau, CyclicLR,\n                                        # OneCycleLR, CosineAnnealingWarmRestarts,\n```"
    },
    {
      "id": "s3-16",
      "sectionId": "s3",
      "title": "Datasets",
      "body": "```\nDataset                    # abstract class representing dataset\nTensorDataset              # labelled dataset in the form of tensors\nConcat Dataset             # concatenation of Datasets\n```"
    },
    {
      "id": "s3-17",
      "sectionId": "s3",
      "title": "Dataloaders and DataSamplers",
      "body": "```\nDataLoader(dataset, batch_size=1, ...)      # loads data batches agnostic\n                                            # of structure of individual data points\n\nsampler.Sampler(dataset,...)                # abstract class dealing with\n                                            # ways to sample from dataset\n\nsampler.XSampler where ...                  # Sequential, Random, SubsetRandom,\n                                            # WeightedRandom, Batch, Distributed\n```"
    }
  ],
  "source": {
    "repo": "https://github.com/Fechin/reference",
    "path": "source/_posts/pytorch.md",
    "ref": "main",
    "url": "https://github.com/Fechin/reference/tree/main/source/_posts/pytorch.md",
    "lang": "en",
    "mode": "local"
  }
}