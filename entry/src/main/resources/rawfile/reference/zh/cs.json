{
  "id": "cs",
  "name": "C# 备忘清单",
  "title": "提供基本语法和方法的 C# 快速参考备忘单",
  "icon": "https://raw.githubusercontent.com/jaywcjlove/reference/main/assets/cs.svg",
  "sections": [
    {
      "id": "intro",
      "title": "简介",
      "startIndex": 0
    },
    {
      "id": "s1",
      "title": "入门",
      "startIndex": 1
    },
    {
      "id": "s2",
      "title": "C# 数据类型",
      "startIndex": 25
    },
    {
      "id": "s3",
      "title": "C# 字符串",
      "startIndex": 42
    },
    {
      "id": "s4",
      "title": "运算符和表达式",
      "startIndex": 54
    },
    {
      "id": "s5",
      "title": "类",
      "startIndex": 95
    },
    {
      "id": "s6",
      "title": "元组",
      "startIndex": 131
    },
    {
      "id": "s7",
      "title": "集合",
      "startIndex": 141
    },
    {
      "id": "s8",
      "title": "LINQ",
      "startIndex": 164
    },
    {
      "id": "s9",
      "title": "事件和委托",
      "startIndex": 191
    },
    {
      "id": "s10",
      "title": "语法糖",
      "startIndex": 230
    },
    {
      "id": "s11",
      "title": "杂项",
      "startIndex": 243
    }
  ],
  "cards": [
    {
      "id": "intro-0",
      "sectionId": "intro",
      "title": "简介",
      "kind": "text",
      "body": "提供基本语法和方法的 C# 快速参考备忘单"
    },
    {
      "id": "s1-1",
      "sectionId": "s1",
      "title": "Hello.cs",
      "kind": "code",
      "lang": "cs",
      "code": "class Hello {\n  // main method\n  static void Main(string[] args)\n  {\n    // 输出: Hello, world!\n    Console.WriteLine(\"Hello, world!\");\n  }\n}"
    },
    {
      "id": "s1-2",
      "sectionId": "s1",
      "title": "Hello.cs",
      "kind": "text",
      "body": "编译运行（确保在项目目录下）"
    },
    {
      "id": "s1-3",
      "sectionId": "s1",
      "title": "Hello.cs",
      "kind": "code",
      "lang": "shell",
      "code": "$ dotnet run\nHello, world!"
    },
    {
      "id": "s1-4",
      "sectionId": "s1",
      "title": "命名空间",
      "kind": "code",
      "lang": "cs",
      "code": "//使用时 using 命名名称\nusing Test;\n//创建：\nnamespace Test{\n  class Test_className{\n    // main方法是程序的主入口\n    public void Myclass() {\n      console.writeline(\"Test\")\n    }\n  }\n}"
    },
    {
      "id": "s1-5",
      "sectionId": "s1",
      "title": "访问修饰符",
      "kind": "qa",
      "front": "`public`",
      "back": "访问不受限制"
    },
    {
      "id": "s1-6",
      "sectionId": "s1",
      "title": "访问修饰符",
      "kind": "qa",
      "front": "`protected`",
      "back": "访问限于包含类或派生自包含类的类型 (该类内部和继承类中可以访问)"
    },
    {
      "id": "s1-7",
      "sectionId": "s1",
      "title": "访问修饰符",
      "kind": "qa",
      "front": "`internal`",
      "back": "访问限于当前程序集"
    },
    {
      "id": "s1-8",
      "sectionId": "s1",
      "title": "访问修饰符",
      "kind": "qa",
      "front": "`protected internal`",
      "back": "访问限于当前程序集或派生自包含类的类型"
    },
    {
      "id": "s1-9",
      "sectionId": "s1",
      "title": "访问修饰符",
      "kind": "qa",
      "front": "`private`",
      "back": "访问限于包含类"
    },
    {
      "id": "s1-10",
      "sectionId": "s1",
      "title": "访问修饰符",
      "kind": "qa",
      "front": "`private protected`",
      "back": "访问限于包含类或当前程序集中派生自包含类的类型,自 C# 7.2 之后可用"
    },
    {
      "id": "s1-11",
      "sectionId": "s1",
      "title": "字符串",
      "kind": "code",
      "lang": "cs",
      "code": "string first = \"John\";\nstring last = \"Doe\";\n// 字符串连接\nstring name = first + \" \" + last;\nConsole.WriteLine(name); // => John Doe"
    },
    {
      "id": "s1-12",
      "sectionId": "s1",
      "title": "字符串",
      "kind": "text",
      "body": "查看: [C#字符串](#c-字符串)"
    },
    {
      "id": "s1-13",
      "sectionId": "s1",
      "title": "注释",
      "kind": "code",
      "lang": "cs",
      "code": "// 单行注释\n\n/* \n * 多行\n * 注释 - 用于文档 \n */\n\n// TODO：\n// 向IDE中的任务列表添加注释（VS、Rider都支持）\n/// XML 单行注释，用于文档"
    },
    {
      "id": "s1-14",
      "sectionId": "s1",
      "title": "用户输入",
      "kind": "text",
      "body": "```cs showLineNumbers\nConsole.WriteLine(\"Enter number:\");\nif(int.TryParse(Console.ReadLine(),out int input))\n{\n// 输入验证\nConsole.WriteLine($\"You entered {input}\");\n}"
    },
    {
      "id": "s1-15",
      "sectionId": "s1",
      "title": "用户输入",
      "kind": "code",
      "lang": "",
      "code": "\n### 条件判断\n\n```cs\nint j = 10;\nif (j == 10) {\n  Console.WriteLine(\"I get printed\");\n} else if (j > 10) {\n  Console.WriteLine(\"I don't\");\n} else {\n  Console.WriteLine(\"I also don't\");\n}"
    },
    {
      "id": "s1-16",
      "sectionId": "s1",
      "title": "变量",
      "kind": "code",
      "lang": "cs",
      "code": "int intNum = 9;\nlong longNum = 9999999;\nfloat floatNum = 9.99F;\ndouble doubleNum = 99.999;\ndecimal decimalNum = 99.9999M;\nchar letter = 'D';\nbool @bool = true;\nstring site = \"jaywcjlove.github.io\";\nvar num = 999;\nvar str = \"999\";\nvar bo = false;"
    },
    {
      "id": "s1-17",
      "sectionId": "s1",
      "title": "循环",
      "kind": "code",
      "lang": "cs",
      "code": "int[] numbers = {1, 2, 3, 4, 5};\nfor(int i = 0; i < numbers.Length; i++) {\n  Console.WriteLine(numbers[i]);\n}"
    },
    {
      "id": "s1-18",
      "sectionId": "s1",
      "title": "循环",
      "kind": "text",
      "body": "---"
    },
    {
      "id": "s1-19",
      "sectionId": "s1",
      "title": "循环",
      "kind": "code",
      "lang": "cs",
      "code": "foreach(int num in numbers) {\n  Console.WriteLine(num);\n}"
    },
    {
      "id": "s1-20",
      "sectionId": "s1",
      "title": "循环",
      "kind": "text",
      "body": "---"
    },
    {
      "id": "s1-21",
      "sectionId": "s1",
      "title": "循环",
      "kind": "code",
      "lang": "cs",
      "code": "while(true)\n{\n   Console.WriteLine(\"只要给定的条件为真，while 循环语句会重复执行\");\n}"
    },
    {
      "id": "s1-22",
      "sectionId": "s1",
      "title": "循环",
      "kind": "text",
      "body": "---"
    },
    {
      "id": "s1-23",
      "sectionId": "s1",
      "title": "循环",
      "kind": "code",
      "lang": "cs",
      "code": "do\n{\n   Console.WriteLine(\"与 while 类似，do...while 会确保至少执行一次循环。\");\n} while( true );"
    },
    {
      "id": "s1-24",
      "sectionId": "s1",
      "title": "数组",
      "kind": "code",
      "lang": "cs",
      "code": "char[] chars = new char[10];\nchars[0] = 'a';\nchars[1] = 'b';\nstring[] letters = {\"A\", \"B\", \"C\"};\nint[] mylist = {100, 200};\nbool[] answers = {true, false};"
    },
    {
      "id": "s2-25",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`bool`",
      "back": "布尔型 | `Boolean` | 1 | true/false"
    },
    {
      "id": "s2-26",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`sbyte`",
      "back": "有符号字节型 | `SByte` | 1 | -128 ~ 127"
    },
    {
      "id": "s2-27",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`byte`",
      "back": "字节型 | `Byte` | 1 | 0 ~ 255"
    },
    {
      "id": "s2-28",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`short`",
      "back": "短整型 | `Int16` | 2 | -32,768 ~ 32,767"
    },
    {
      "id": "s2-29",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`ushort`",
      "back": "无符号短整型 | `UInt16` | 2 | 0 ~ 65,535"
    },
    {
      "id": "s2-30",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`int`",
      "back": "整型 | `Int32` | 4 | -2,147,483,648 ~ 2,147,483,647"
    },
    {
      "id": "s2-31",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`uint`",
      "back": "无符号整型 | `UInt32` | 4 | 0 ~ 4,294,967,295"
    },
    {
      "id": "s2-32",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`long`",
      "back": "长整型 | `Int64` | 8 | -2^63 ~ 2^63-1"
    },
    {
      "id": "s2-33",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`ulong`",
      "back": "无符号长整型 | `UInt64` | 8 | 0 ~ 2^64-1"
    },
    {
      "id": "s2-34",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`char`",
      "back": "字符型 | `Char` | 8 | UTF-16 所编码的字符"
    },
    {
      "id": "s2-35",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`float`",
      "back": "单精度浮点型 | `Single` | 4 | ±1.5x10^45 ~ ±3.4x10^38"
    },
    {
      "id": "s2-36",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`double`",
      "back": "双精度浮点型 | `Double` | 8 | ±5.0x10^-324 ~ ±1.7x10^308"
    },
    {
      "id": "s2-37",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`nint`",
      "back": "指针型 | `IntPtr` | 与指针相同 | 与指针相同（受操作系统和处理器位宽影响）"
    },
    {
      "id": "s2-38",
      "sectionId": "s2",
      "title": "原始数据类型",
      "kind": "qa",
      "front": "`nuint`",
      "back": "无符号指针型 | `UIntPtr` | 与指针相同 | 与指针相同（受操作系统和处理器位宽影响）"
    },
    {
      "id": "s2-39",
      "sectionId": "s2",
      "title": "基本数据类型",
      "kind": "qa",
      "front": "(除指针型外的全部原始数据类型)",
      "back": "- | - | 原始数据类型都是值类型，基本数据类型包含部分本质上是引用的数据类型"
    },
    {
      "id": "s2-40",
      "sectionId": "s2",
      "title": "基本数据类型",
      "kind": "qa",
      "front": "`string`",
      "back": "字符串 | `String` | 可变长度"
    },
    {
      "id": "s2-41",
      "sectionId": "s2",
      "title": "基本数据类型",
      "kind": "qa",
      "front": "`decimal`",
      "back": "十进制浮点数 | `Decimal` | 适合处理货币等计算，16字节长，不遵循 IEEE 754 关于浮点数的规则"
    },
    {
      "id": "s3-42",
      "sectionId": "s3",
      "title": "字符串连接",
      "kind": "code",
      "lang": "cs",
      "code": "string first = \"John\";\nstring last = \"Doe\";\nstring name = first + \" \" + last;\nConsole.WriteLine(name); // => John Doe"
    },
    {
      "id": "s3-43",
      "sectionId": "s3",
      "title": "字符串插值",
      "kind": "code",
      "lang": "cs",
      "code": "string first = \"John\";\nstring last = \"Doe\";\nstring name = $\"{first} {last}\";\nConsole.WriteLine(name); // => John Doe"
    },
    {
      "id": "s3-44",
      "sectionId": "s3",
      "title": "字符串成员",
      "kind": "text",
      "body": "成员 | 说明\n:- | -\n`Length`    | 返回字符串长度的属性\n`Compare()`   | 比较两个字符串的静态方法\n`Contains()`  | 确定字符串是否包含特定的子字符串\n`Equals()`    | 确定两个字符串是否具有相同的字符数据\n`Format()`    | 通过 {0} 表示法和使用其他原语格式化字符串\n`Trim()`      | 从尾随和前导字符中删除特定字符的所有实例。 默认删除前导和尾随空格\n`Split()`     | 删除提供的字符并从两侧的剩余字符中创建一个数组\n<!--rehype:className=show-header-->"
    },
    {
      "id": "s3-45",
      "sectionId": "s3",
      "title": "逐字字符串",
      "kind": "text",
      "body": "```cs showLineNumbers\nstring longString = @\"I can type any characters in here !#@$%^&*()__+ '' \\n \\t except double quotes and I will be taken literally. I even work with multiple lines.\";"
    },
    {
      "id": "s3-46",
      "sectionId": "s3",
      "title": "逐字字符串",
      "kind": "code",
      "lang": "",
      "code": "<!--rehype:className=wrap-text-->\n\n### 成员示例\n\n```cs\n// 使用 System.String 的属性\nstring lengthOfString = \"How long?\";\nlengthOfString.Length           // => 9\n// 使用 System.String 的方法\nlengthOfString.Contains(\"How\"); // => true"
    },
    {
      "id": "s3-47",
      "sectionId": "s3",
      "title": "频繁字符串拼接",
      "kind": "code",
      "lang": "cs",
      "code": "var sb = new StringBuilder();\nfor (int i = 0; i < 100; i++)\n{\n    sb.Append(i.ToString());\n}\nConsole.WriteLine(sb.ToString());\n// => 123456789...."
    },
    {
      "id": "s3-48",
      "sectionId": "s3",
      "title": "频繁字符串拼接",
      "kind": "text",
      "body": "对于频繁拼接字符串的场景（如：成百上千次循环），使用 `System.Text.StringBuilder` 提升性能"
    },
    {
      "id": "s3-49",
      "sectionId": "s3",
      "title": "原始字符串文本",
      "kind": "code",
      "lang": "cs",
      "code": "// C#11 语法, 至少3个双引号(\"\"\")开头和结尾，内容可以输入任何原始字符\n// 单行: 左引号，右引号，内容 三者同行\nstring singleLine = \"\"\"Content begin \"Hello World!\" end.\"\"\";\n\n// 多行：左引号，右引号各一行，内容需与右引号缩进对齐\nstring multiLine = \"\"\"\n    Content begin \"Hello World!\" /\\n<>\"\" end.\n    \"\"\";\nConsole.WriteLine(multiLine); // => Content begin \"Hello World!\" /\\n<>\"\" end."
    },
    {
      "id": "s3-50",
      "sectionId": "s3",
      "title": "字符串判空",
      "kind": "code",
      "lang": "cs",
      "code": "string name; //空引用\nstring gender = \"\"; //空值\n\n// 使用 string.IsNullOrEmpty(字符串) 方法，返回 bool 型\nConsole.WriteLine(string.IsNullOrEmpty(name)); //输出 true\nConsole.WriteLine(string.IsNullOrEmpty(gender)); // 输出 true"
    },
    {
      "id": "s3-51",
      "sectionId": "s3",
      "title": "字符串截取",
      "kind": "code",
      "lang": "cs",
      "code": "string Str = \"字符串截取\";\nStr = Str.Substring(2, 1);\nConsole.WriteLine(Str);\n// 输出结果“串”，意为从第二个下标开始截取一位字符"
    },
    {
      "id": "s3-52",
      "sectionId": "s3",
      "title": "字符串分割",
      "kind": "code",
      "lang": "cs",
      "code": "string Name = \"字A符A串A分A割\";\nstring[] Names=Name.Split(new char[] { 'A' });\n// 会以A为媒介把字符串分成若干份\nfor (int i = 0; i < Names.Length; i++)\n{\n    Console.Write(Names[i]);\n}"
    },
    {
      "id": "s3-53",
      "sectionId": "s3",
      "title": "字符串替换",
      "kind": "code",
      "lang": "cs",
      "code": "string Rep = \"字符1替换\";\nRep = Rep.Replace(\"1\", \"串\");\nConsole.WriteLine(Rep);\n// 会把字符中的 “1”替换成“串”"
    },
    {
      "id": "s4-54",
      "sectionId": "s4",
      "title": "逻辑运算",
      "kind": "code",
      "lang": "cs",
      "code": "//或运算, 与运算, 非运算\nbool A = true;\nbool B = false;\nbool Or = A || B; // = A | B\nbool And = A && B; // = A & B\nbool Not = !A;\n// ||,&& 与 |,& 分别为逻辑运算和条件逻辑运算, 两者的区别在于, \n// 前者仅在必要时才会计算右侧的值, 后者始终计算右侧的值. 例如:\nbool C = false;\nbool D = true;\nbool CalcD() {\n  D = !D;\n  return D;\n}\nbool E = C && CalcD(); // C: false, D: false, E: false\nbool F = C & CalcD(); // C:false, D: true, F: false\n// 两种运算方法稍有不同, 计算结果始终相同, 但第二种可能造成其他影响.\n//异或运算\nbool Xor = A ^ B;"
    },
    {
      "id": "s4-55",
      "sectionId": "s4",
      "title": "逻辑运算",
      "kind": "text",
      "body": "C# 中的逻辑运算支持可空布尔类型运算. 注意条件逻辑运算不支持可空布尔类型."
    },
    {
      "id": "s4-56",
      "sectionId": "s4",
      "title": "逻辑运算",
      "kind": "text",
      "body": "x |  y | x & y | x \\| y | x ^ y | ! x\n:- | - | --- | --- | --- | --\n<code>true</code> | <code>true</code> | <code>true</code> | <code>true</code> | false | false\n<code>true</code> | false | false | <code>true</code> | <code>true</code> | false\n<code>true</code> | <pur>null</pur> | <pur>null</pur> | <code>true</code> | <pur>null</pur> | false\nfalse | <code>true</code> | false | <code>true</code> | <code>true</code> | <code>true</code>\nfalse | false | false | false | false | <code>true</code>\nfalse | <pur>null</pur> | false | <pur>null</pur> | <pur>null</pur> | <code>true</code>\n<pur>null</pur> | <code>true</code> | <pur>null</pur> | <code>true</code> | <pur>null</pur> | <pur>null</pur>\n<pur>null</pur> | false | false | <pur>null</pur> | <pur>null</pur> | <pur>null</pur>\n<pur>null</pur> | <pur>null</pur> | <pur>null</pur> | <pur>null</pur> | <pur>null</pur> | <pur>null</pur>\n<!--rehype:className=show-header-->"
    },
    {
      "id": "s4-57",
      "sectionId": "s4",
      "title": "关系运算符",
      "kind": "text",
      "body": "C# 支持下表中的所有关系运算符。假设变量 A 的值为 1，变量 B 的值为 2，则："
    },
    {
      "id": "s4-58",
      "sectionId": "s4",
      "title": "关系运算符",
      "kind": "qa",
      "front": "==",
      "back": "检查两个操作数的值是否相等，如果相等则条件为真。 | (A == B) 不为真。"
    },
    {
      "id": "s4-59",
      "sectionId": "s4",
      "title": "关系运算符",
      "kind": "qa",
      "front": "!=",
      "back": "检查两个操作数的值是否相等，如果不相等则条件为真。 | (A != B) 为真。"
    },
    {
      "id": "s4-60",
      "sectionId": "s4",
      "title": "关系运算符",
      "kind": "qa",
      "front": ">",
      "back": "检查左操作数的值是否大于右操作数的值，如果是则条件为真。 | (A > B) 不为真。"
    },
    {
      "id": "s4-61",
      "sectionId": "s4",
      "title": "关系运算符",
      "kind": "qa",
      "front": "<",
      "back": "检查左操作数的值是否小于右操作数的值，如果是则条件为真。 | (A < B) 为真。"
    },
    {
      "id": "s4-62",
      "sectionId": "s4",
      "title": "关系运算符",
      "kind": "qa",
      "front": ">=",
      "back": "检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 不为真。"
    },
    {
      "id": "s4-63",
      "sectionId": "s4",
      "title": "关系运算符",
      "kind": "qa",
      "front": "<=",
      "back": "检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。"
    },
    {
      "id": "s4-64",
      "sectionId": "s4",
      "title": "算术运算符",
      "kind": "text",
      "body": "C# 支持下表中的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则："
    },
    {
      "id": "s4-65",
      "sectionId": "s4",
      "title": "算术运算符",
      "kind": "qa",
      "front": "+",
      "back": "把两个操作数相加 | A + B 将得到 30"
    },
    {
      "id": "s4-66",
      "sectionId": "s4",
      "title": "算术运算符",
      "kind": "qa",
      "front": "-",
      "back": "从第一个操作数中减去第二个操作数 | A - B 将得到 -10"
    },
    {
      "id": "s4-67",
      "sectionId": "s4",
      "title": "算术运算符",
      "kind": "qa",
      "front": "\\*",
      "back": "把两个操作数相乘 | A \\* B 将得到 200"
    },
    {
      "id": "s4-68",
      "sectionId": "s4",
      "title": "算术运算符",
      "kind": "qa",
      "front": "/",
      "back": "分子除以分母 | B / A 将得到 2"
    },
    {
      "id": "s4-69",
      "sectionId": "s4",
      "title": "算术运算符",
      "kind": "qa",
      "front": "%",
      "back": "取模运算符，整除后的余数 | B % A 将得到 0"
    },
    {
      "id": "s4-70",
      "sectionId": "s4",
      "title": "算术运算符",
      "kind": "qa",
      "front": "++",
      "back": "自增运算符，整数值增加 1 | A++ 将得到 11"
    },
    {
      "id": "s4-71",
      "sectionId": "s4",
      "title": "算术运算符",
      "kind": "qa",
      "front": "--",
      "back": "自减运算符，整数值减少 1 | A-- 将得到 9"
    },
    {
      "id": "s4-72",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "text",
      "body": "下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。"
    },
    {
      "id": "s4-73",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "后缀",
      "back": "() [] -> . ++ - - | 从左到右"
    },
    {
      "id": "s4-74",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "一元",
      "back": "+ - ! ~ ++ - - (type)\\* & sizeof | 从右到左"
    },
    {
      "id": "s4-75",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "乘除",
      "back": "\\* / % | 从左到右"
    },
    {
      "id": "s4-76",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "加减",
      "back": "+ - | 从左到右"
    },
    {
      "id": "s4-77",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "移位",
      "back": "<< >> | 从左到右"
    },
    {
      "id": "s4-78",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "关系",
      "back": "< <= > >= | 从左到右"
    },
    {
      "id": "s4-79",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "相等",
      "back": "== != | 从左到右"
    },
    {
      "id": "s4-80",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "位与 AND",
      "back": "& | 从左到右"
    },
    {
      "id": "s4-81",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "位异或 XOR",
      "back": "^ | 从左到右"
    },
    {
      "id": "s4-82",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "位或 OR",
      "back": "\\ |  | 从左到右"
    },
    {
      "id": "s4-83",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "逻辑与 AND",
      "back": "&& | 从左到右"
    },
    {
      "id": "s4-84",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "逻辑或 OR",
      "back": "\\ | \\ |  | 从左到右"
    },
    {
      "id": "s4-85",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "条件",
      "back": "?: | 从右到左"
    },
    {
      "id": "s4-86",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "赋值",
      "back": "= += -= \\*= /= %=>>= <<= &= ^= \\ | = | 从右到左"
    },
    {
      "id": "s4-87",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "qa",
      "front": "逗号",
      "back": ", | 从左到右"
    },
    {
      "id": "s4-88",
      "sectionId": "s4",
      "title": "运算符优先级",
      "kind": "text",
      "body": "运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。"
    },
    {
      "id": "s4-89",
      "sectionId": "s4",
      "title": "逻辑非运算符",
      "kind": "code",
      "lang": "cs",
      "code": "bool passed = false;\nConsole.WriteLine(!passed); // 输出: True\nConsole.WriteLine(!true);   // 输出: False"
    },
    {
      "id": "s4-90",
      "sectionId": "s4",
      "title": "逻辑“与”运算符 &",
      "kind": "code",
      "lang": "cs",
      "code": "bool SecondOperand()\n{\n    Console.WriteLine(\"计算第二个操作数\");\n    return true;\n}\n\nbool a = false & SecondOperand();\nConsole.WriteLine(a);\n// 输出:\n// 计算第二个操作数\n// False\n\nbool b = true & SecondOperand();\nConsole.WriteLine(b);\n// 输出:\n// 计算第二个操作数\n// True"
    },
    {
      "id": "s4-91",
      "sectionId": "s4",
      "title": "逻辑异或运算符 ^",
      "kind": "code",
      "lang": "cs",
      "code": "Console.WriteLine(true ^ true);  // 输出: False\nConsole.WriteLine(true ^ false); // 输出: True\nConsole.WriteLine(false ^ true); // 输出: True\nConsole.WriteLine(false ^ false);// 输出: False"
    },
    {
      "id": "s4-92",
      "sectionId": "s4",
      "title": "逻辑或运算符 |",
      "kind": "code",
      "lang": "cs",
      "code": "bool SecondOperand()\n{\n    Console.WriteLine(\"计算第二个操作数\");\n    return true;\n}\n\nbool a = true | SecondOperand();\nConsole.WriteLine(a);\n// 输出:\n// 计算第二个操作数\n// True\n\nbool b = false | SecondOperand();\nConsole.WriteLine(b);\n// 输出:\n// 计算第二个操作数\n// True"
    },
    {
      "id": "s4-93",
      "sectionId": "s4",
      "title": "条件逻辑“与”运算符 &&",
      "kind": "code",
      "lang": "cs",
      "code": "bool SecondOperand()\n{\n    Console.WriteLine(\"计算第二个操作数\");\n    return true;\n}\n\nbool a = false && SecondOperand();\nConsole.WriteLine(a);\n// 输出:\n// False\n\nbool b = true && SecondOperand();\nConsole.WriteLine(b);\n// 输出:\n// 计算第二个操作数\n// True"
    },
    {
      "id": "s4-94",
      "sectionId": "s4",
      "title": "条件逻辑或运算符 ||",
      "kind": "code",
      "lang": "cs",
      "code": "bool SecondOperand()\n{\n    Console.WriteLine(\"计算第二个操作数\");\n    return true;\n}\n\nbool a = true || SecondOperand();\nConsole.WriteLine(a);\n// 输出:\n// True\n\nbool b = false || SecondOperand();\nConsole.WriteLine(b);\n// 输出:\n// 计算第二个操作数\n// True"
    },
    {
      "id": "s5-95",
      "sectionId": "s5",
      "title": "成员变量",
      "kind": "code",
      "lang": "cs",
      "code": "public class MyClass\n{\n    // 私有变量\n    private int myVariable;\n    // 公有属性\n    public string MyProperty { get; set; }\n}"
    },
    {
      "id": "s5-96",
      "sectionId": "s5",
      "title": "静态成员",
      "kind": "code",
      "lang": "cs",
      "code": "public class MyClass\n{\n    public static int StaticVariable = 10;\n    public static void StaticMethod()\n    {\n        // 静态方法体\n    }\n}"
    },
    {
      "id": "s5-97",
      "sectionId": "s5",
      "title": "构造函数",
      "kind": "code",
      "lang": "cs",
      "code": "public class MyClass\n{\n    // 默认构造函数\n    public MyClass() \n    {\n        // 初始化代码\n    }\n\n    // 自定义构造函数\n    public MyClass(int value) \n    {\n        // 使用传入的值初始化\n    }\n\n    // 析构函数\n    ~MyClass() {\n        // Destructor body.\n    }\n\n}"
    },
    {
      "id": "s5-98",
      "sectionId": "s5",
      "title": "方法",
      "kind": "code",
      "lang": "cs",
      "code": "public class MyClass\n{\n    // 无返回值方法\n    public void MyMethod()\n    {\n        // 方法体\n    }\n    // 有返回值方法\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n}"
    },
    {
      "id": "s5-99",
      "sectionId": "s5",
      "title": "属性",
      "kind": "code",
      "lang": "cs",
      "code": "public class MyClass\n{\n    private string myField;\n    \n    public string MyProperty\n    {\n        get { return myField; }\n        set { myField = value; }\n    }\n}"
    },
    {
      "id": "s5-100",
      "sectionId": "s5",
      "title": "接口",
      "kind": "code",
      "lang": "cs",
      "code": "public interface IMyInterface\n{\n    void MyMethod(); // 接口方法声明\n}\n\npublic class MyClass : IMyInterface\n{\n    public void MyMethod() // 实现接口方法\n    {\n        // 实现代码\n    }\n}"
    },
    {
      "id": "s5-101",
      "sectionId": "s5",
      "title": "继承",
      "kind": "text",
      "body": "注意"
    },
    {
      "id": "s5-102",
      "sectionId": "s5",
      "title": "继承",
      "kind": "text",
      "body": "• 在类定义中，只能有一个基类\n• 继承了一个抽象类，必须实现所继承的所有抽象成员(除非派生类也是抽象的)\n• 编译器不允许派生类的可访问性高于基类\n• 内部类可以继承于一个公共基类，但公共类不能继承于一个内部基类"
    },
    {
      "id": "s5-103",
      "sectionId": "s5",
      "title": "继承",
      "kind": "text",
      "body": "因此，下述代码是合法的："
    },
    {
      "id": "s5-104",
      "sectionId": "s5",
      "title": "继承",
      "kind": "code",
      "lang": "cs",
      "code": "public class MyBase\n{\n    // Class members.\n}\ninternal class MyClass : MyBase\n{\n    // Class members.\n}"
    },
    {
      "id": "s5-105",
      "sectionId": "s5",
      "title": "继承",
      "kind": "text",
      "body": "下述代码不能编译:"
    },
    {
      "id": "s5-106",
      "sectionId": "s5",
      "title": "继承",
      "kind": "code",
      "lang": "cs",
      "code": "internal class MyBase\n{\n    // Class members.\n}\npublic class MyClass : MyBase\n{\n    // Class members.\n}"
    },
    {
      "id": "s5-107",
      "sectionId": "s5",
      "title": "继承",
      "kind": "text",
      "body": "如果没有使用基类，被定义的类就只继承于基类 System.Object(它在 C# 中的别名是 object)。在继承层次结构中，所有类的根都是 `System.Object`"
    },
    {
      "id": "s5-108",
      "sectionId": "s5",
      "title": "访问修饰符",
      "kind": "text",
      "body": ":-- | :--\n:-- | :--\n`public` | 公有，可从任何位置访问\n`private` | 私有，只能在当前类中访问\n`protected` | 受保护，只能在当前类和派生类中访问\n`internal` | 内部，只能在同一程序集中访问\n`protected internal` | 受保护的内部，可以在同一程序集中的任何地方访问，以及派生类中\n`private protected` | 私有保护，只能在同一程序集中的派生类中访问\n<!--rehype:className=style-list-->"
    },
    {
      "id": "s5-109",
      "sectionId": "s5",
      "title": "字段的特殊修饰符",
      "kind": "qa",
      "front": "`readonly`",
      "back": "表示这个字段只能在执行构造函数的过程中赋值，或由初始化赋值语句赋值"
    },
    {
      "id": "s5-110",
      "sectionId": "s5",
      "title": "字段的特殊修饰符",
      "kind": "qa",
      "front": "`static`",
      "back": "静态字段，必须通过类名来访问，例如：Class.staticField"
    },
    {
      "id": "s5-111",
      "sectionId": "s5",
      "title": "字段的特殊修饰符",
      "kind": "qa",
      "front": "`const`",
      "back": "常量字段，但同时也是静态字段，自带static"
    },
    {
      "id": "s5-112",
      "sectionId": "s5",
      "title": "方法的特殊修饰符",
      "kind": "qa",
      "front": "`static`",
      "back": "静态方法，只能通过类名来调用方法"
    },
    {
      "id": "s5-113",
      "sectionId": "s5",
      "title": "方法的特殊修饰符",
      "kind": "qa",
      "front": "`virtual`",
      "back": "方法可以被重写"
    },
    {
      "id": "s5-114",
      "sectionId": "s5",
      "title": "方法的特殊修饰符",
      "kind": "qa",
      "front": "`abstract`",
      "back": "抽象方法，只用于抽象类"
    },
    {
      "id": "s5-115",
      "sectionId": "s5",
      "title": "方法的特殊修饰符",
      "kind": "qa",
      "front": "`override`",
      "back": "方法重写了基类的一个方法（如果方法被重写，就必须使用该关键字）。"
    },
    {
      "id": "s5-116",
      "sectionId": "s5",
      "title": "方法的特殊修饰符",
      "kind": "qa",
      "front": "`extern`",
      "back": "方法定义放在其他地方，可以在项目外部提供方法的实际实现代码"
    },
    {
      "id": "s5-117",
      "sectionId": "s5",
      "title": "方法的特殊修饰符",
      "kind": "qa",
      "front": "`sealed`",
      "back": "如果使用了 `override` ，也可以使用 `sealed` 来指定在派生类中不能再对这个方法进行进一步的修改，即这个方法不能被派生类重写"
    },
    {
      "id": "s5-118",
      "sectionId": "s5",
      "title": "公共类",
      "kind": "code",
      "lang": "cs",
      "code": "public class MyClass\n{\n  ...\n}"
    },
    {
      "id": "s5-119",
      "sectionId": "s5",
      "title": "公共类",
      "kind": "text",
      "body": "添加 `public` 声明为公共类"
    },
    {
      "id": "s5-120",
      "sectionId": "s5",
      "title": "私有类",
      "kind": "code",
      "lang": "cs",
      "code": "private class MyClass\n{\n  ...\n}"
    },
    {
      "id": "s5-121",
      "sectionId": "s5",
      "title": "私有类",
      "kind": "text",
      "body": "添加 `public` 声明为公共类"
    },
    {
      "id": "s5-122",
      "sectionId": "s5",
      "title": "命名约定",
      "kind": "text",
      "body": "• 类名使用 PascalCase 格式\n• 成员变量和方法名使用 camelCase 格式\n• 公有成员和类型名应该使用有意义的名字"
    },
    {
      "id": "s5-123",
      "sectionId": "s5",
      "title": "默认情况(默认情况即为内部类)",
      "kind": "code",
      "lang": "cs",
      "code": "class MyClass \n{\n  ...\n}\ninternal class MyCalss\n{\n  ...\n}"
    },
    {
      "id": "s5-124",
      "sectionId": "s5",
      "title": "默认情况(默认情况即为内部类)",
      "kind": "text",
      "body": "上面两个类相同，声明为内部（`internal`）类，只能在当前项目中的代码才能访问它"
    },
    {
      "id": "s5-125",
      "sectionId": "s5",
      "title": "默认情况(默认情况即为内部类)",
      "kind": "text",
      "body": "---"
    },
    {
      "id": "s5-126",
      "sectionId": "s5",
      "title": "默认情况(默认情况即为内部类)",
      "kind": "text",
      "body": "• 抽象类与密封类为互斥关系\n• 抽象类不能实例化，允许继承\n• 可以有抽象成员，密封类不允许继承\n• 都可以声明为公共类（public）和内部类（internal）"
    },
    {
      "id": "s5-127",
      "sectionId": "s5",
      "title": "抽象类与密封类",
      "kind": "text",
      "body": "#### 抽象类（abstract）"
    },
    {
      "id": "s5-128",
      "sectionId": "s5",
      "title": "抽象类与密封类",
      "kind": "code",
      "lang": "cs",
      "code": "public abstract class MyClass\n{\n  // 普通公共字段\n  public string id;\n  // 抽象字段\n  public abstract string Name { get; }\n  // 常量字段\n  public const string Description = \"常量\";\n  // 静态字段\n  public static string Order = \"静态\";\n}"
    },
    {
      "id": "s5-129",
      "sectionId": "s5",
      "title": "抽象类与密封类",
      "kind": "text",
      "body": "#### 密封类（sealed"
    },
    {
      "id": "s5-130",
      "sectionId": "s5",
      "title": "抽象类与密封类",
      "kind": "code",
      "lang": "cs",
      "code": "public sealed class MyClass\n{\n  ...\n}"
    },
    {
      "id": "s6-131",
      "sectionId": "s6",
      "title": "基本使用",
      "kind": "text",
      "body": "不带名称的基本元组创建"
    },
    {
      "id": "s6-132",
      "sectionId": "s6",
      "title": "基本使用",
      "kind": "code",
      "lang": "cs",
      "code": "(\n    int item1,\n    string item2,\n    bool item3\n) tuple1 = (1, \"Hello\", true);\n\nConsole.WriteLine(\n    $\"Item1: {tuple1.Item1}, \" +\n    $\"Item2: {tuple1.Item2}, \" +\n    $\"Item3: {tuple1.Item3}\"\n);"
    },
    {
      "id": "s6-133",
      "sectionId": "s6",
      "title": "基本使用",
      "kind": "text",
      "body": "带名称的元组创建（C# 7.0及以上版本）"
    },
    {
      "id": "s6-134",
      "sectionId": "s6",
      "title": "基本使用",
      "kind": "code",
      "lang": "cs",
      "code": "(\n    string FirstName,\n    string LastName,\n    int Age\n) person = (\"Alice\", \"Smith\", 30);\n\nConsole.WriteLine(\n    $\"First Name: {person.FirstName}, \" +\n    $\"Last Name: {person.LastName}, \" +\n    $\"Age: {person.Age}\"\n);"
    },
    {
      "id": "s6-135",
      "sectionId": "s6",
      "title": "方法调用与接收",
      "kind": "code",
      "lang": "cs",
      "code": "public (int Id, string Name, double Score) GetStudentInfo()\n{\n    return (123, \"John Doe\", 95.5);\n}"
    },
    {
      "id": "s6-136",
      "sectionId": "s6",
      "title": "方法调用与接收",
      "kind": "text",
      "body": "使用"
    },
    {
      "id": "s6-137",
      "sectionId": "s6",
      "title": "方法调用与接收",
      "kind": "code",
      "lang": "cs",
      "code": "(\n    var id,\n    var name,\n    var score\n) = GetStudentInfo();\n\nConsole.WriteLine(\n    $\"Id: {id}, \" +\n    $\"Name: {name}, \" +\n    $\"Score: {score}\"\n);"
    },
    {
      "id": "s6-138",
      "sectionId": "s6",
      "title": "类中使用元组",
      "kind": "code",
      "lang": "cs",
      "code": "public class Student\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public double GPA { get; set; }\n\n    public void Deconstruct(out int id, out string name, out double gpa)\n    {\n        id = this.Id;\n        name = this.Name;\n        gpa = this.GPA;\n    }\n}"
    },
    {
      "id": "s6-139",
      "sectionId": "s6",
      "title": "类中使用元组",
      "kind": "text",
      "body": "使用Deconstruct方法创建元组"
    },
    {
      "id": "s6-140",
      "sectionId": "s6",
      "title": "类中使用元组",
      "kind": "code",
      "lang": "cs",
      "code": "Student student = new Student\n{\n    Id = 1,\n    Name = \"Jane\",\n    GPA = 3.8\n};\n\n(int id, string name, double gpa) = student;\nConsole.WriteLine($\"Student Id: {id}, Name: {name}, GPA: {gpa}\");"
    },
    {
      "id": "s7-141",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[List](https://docs.microsoft.com/dotnet/api/system.collections.generic.list-1)",
      "back": "Y | *N* | *N* | 是"
    },
    {
      "id": "s7-142",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[ArrayList](https://docs.microsoft.com/dotnet/api/system.collections.arraylist) (非泛型)",
      "back": "Y | *N* | *N* | 是"
    },
    {
      "id": "s7-143",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[Vector](https://docs.microsoft.com/dotnet/api/system.collections.vector) (非泛型)",
      "back": "*N* | *N* | Y | 是"
    },
    {
      "id": "s7-144",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[LinkedList](https://docs.microsoft.com/dotnet/api/system.collections.generic.linkedlist-1)",
      "back": "Y | *N* | *N* | 是"
    },
    {
      "id": "s7-145",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[ConcurrentBag](https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentbag-1)",
      "back": "*N* | *N* | Y | 是"
    },
    {
      "id": "s7-146",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[HashSet](https://docs.microsoft.com/dotnet/api/system.collections.generic.hashset-1)",
      "back": "*N* | *N* | *N* | 是"
    },
    {
      "id": "s7-147",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[SortedSet](https://docs.microsoft.com/dotnet/api/system.collections.generic.sortedset-1)",
      "back": "*N* | Y | *N* | 是"
    },
    {
      "id": "s7-148",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[ConcurrentDictionary](https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentdictionary-2)",
      "back": "Y | *N* | Y | 是"
    },
    {
      "id": "s7-149",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[Dictionary](https://docs.microsoft.com/dotnet/api/system.collections.generic.dictionary-2)",
      "back": "*N* | *N* | *N* | 是"
    },
    {
      "id": "s7-150",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[SortedDictionary](https://docs.microsoft.com/dotnet/api/system.collections.generic.sorteddictionary-2)",
      "back": "Y | Y | *N* | 是"
    },
    {
      "id": "s7-151",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[Stack](https://docs.microsoft.com/dotnet/api/system.collections.generic.stack-1)",
      "back": "*N* | *N* | *N* | 是"
    },
    {
      "id": "s7-152",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[Queue](https://docs.microsoft.com/dotnet/api/system.collections.generic.queue-1)",
      "back": "*N* | *N* | *N* | 是"
    },
    {
      "id": "s7-153",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[ConcurrentQueue](https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentqueue-1)",
      "back": "*N* | *N* | Y | 是"
    },
    {
      "id": "s7-154",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[ConcurrentStack](https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentstack-1)",
      "back": "*N* | *N* | Y | 是"
    },
    {
      "id": "s7-155",
      "sectionId": "s7",
      "title": "c#集合",
      "kind": "qa",
      "front": "[HashTable](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.hashtable?view=net-6.0)",
      "back": "N | Y | Y | 否"
    },
    {
      "id": "s7-156",
      "sectionId": "s7",
      "title": "List",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建一个整数类型的List\nList<int> numbers = new List<int>();\n\n// 增加（Add）\nnumbers.Add(10);\nnumbers.Add(20);\n//增加30，40两个元素\nnumbers.AddRange(new[] { 30, 40 });\n\n// 删除（Remove）\nif (numbers.Contains(20))\n{\n    numbers.Remove(20);\n}\n\n// 修改（更改特定索引处的元素）\nnumbers[0] = 50; // 直接替换元素\n\n// 查询（Find/Contains）\nbool isPresent = numbers.Contains(50);\n\n// 查找索引\nint index = numbers.IndexOf(40);\nif (index != -1)\n{\n    numbers[index] = 45; // 修改找到的元素\n}"
    },
    {
      "id": "s7-157",
      "sectionId": "s7",
      "title": "HashSet",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建一个字符串类型的HashSet\nHashSet<string> words = new HashSet<string> { \"apple\", \"banana\" };\n\n// 增加（Add）\nwords.Add(\"cherry\");\n\n// 返回 false，因为\"apple\"已存在\nbool wasAdded = words.Add(\"apple\"); \n\n// 删除（Remove）\nwords.Remove(\"banana\");\n\n// 修改 - HashSet不允许直接修改元素\n// 需删除后重新添加\nif (words.Contains(\"cherry\"))\n{\n    words.Remove(\"cherry\");\n    words.Add(\"cherries\");\n}\n\n// 查询（Contains）\nbool containsCherries = words.Contains(\"cherries\");"
    },
    {
      "id": "s7-158",
      "sectionId": "s7",
      "title": "ConcurrentBag",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建一个并发安全的整数集合\nConcurrentBag<int> concurrentNumbers = new ConcurrentBag<int>();\n\n// 增加（Add）\nconcurrentNumbers.Add(1);\nconcurrentNumbers.Add(2);\n\n// 删除（由于ConcurrentBag没有直接的Remove方法，只能通过迭代并尝试移除）\nforeach (var number in concurrentNumbers.ToArray())\n{\n    concurrentNumbers.TryTake(out _number); // 并发安全地移除一个元素\n}"
    },
    {
      "id": "s7-159",
      "sectionId": "s7",
      "title": "ConcurrentBag",
      "kind": "text",
      "body": "修改（无法直接修改，同样需先移除再添加，但由于并发特性，不能保证一定能修改目标元素）。\n在并发环境下尤其复杂，此处省略示例"
    },
    {
      "id": "s7-160",
      "sectionId": "s7",
      "title": "ConcurrentBag",
      "kind": "code",
      "lang": "cs",
      "code": "// 查询（Contains）\nbool hasOne = concurrentNumbers.Contains(1);"
    },
    {
      "id": "s7-161",
      "sectionId": "s7",
      "title": "Stack",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建一个整数栈\nStack<int> stack = new Stack<int>();\nstack.Push(1);\nstack.Push(2);\n\n// 增加（Push）\nstack.Push(3);\n\n// 删除（Pop）并返回栈顶元素\nint topNumber = stack.Pop();\n\n// 修改（Stack不支持直接修改元素，需先Pop再Push）\nint poppedValue = stack.Pop();\n// 替换刚弹出的值\nstack.Push(poppedValue * 2); \n\n// 查询（Peek / Contains） 但不移除栈顶元素\nint peekedValue = stack.Peek();\nbool hasTwo = stack.Contains(2);"
    },
    {
      "id": "s7-162",
      "sectionId": "s7",
      "title": "Dictionary",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建一个键值对字典\nDictionary<string, int> scores = new Dictionary<string, int>\n{\n    { \"Alice\", 85 },\n    { \"Bob\", 90 }\n};\n\n// 增加（Add）\nscores.Add(\"Charlie\", 88);\n\n// 删除（Remove）\nscores.Remove(\"Bob\");\n\n// 修改（Update）\nif (scores.ContainsKey(\"Alice\"))\n{\n    scores[\"Alice\"] = 90; // 直接替换值\n}\n\n// 查询（ContainsKey / GetValueOrDefault）\nbool aliceExists = scores.ContainsKey(\"Alice\");\nint charlieScore = scores.GetValueOrDefault(\"Charlie\", 0);"
    },
    {
      "id": "s7-163",
      "sectionId": "s7",
      "title": "Hashtable",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建一个哈希表\nHashtable hashTable = new Hashtable();\nhashTable.Add(\"key1\", \"value1\");\nhashTable.Add(\"key2\", \"value2\");\n\n// 增加（Add）\nhashTable.Add(\"key3\", \"value3\");\n\n// 删除（Remove）\nhashTable.Remove(\"key1\");\n\n// 修改（Replace）\nobject oldValue;\nif (hashTable.ContainsKey(\"key2\"))\n{\n    oldValue = hashTable[\"key2\"];\n    hashTable[\"key2\"] = \"new_value2\";\n}\n\n// 查询（Contains / GetValue）\nbool hasKey2 = hashTable.ContainsKey(\"key2\");\nstring valueOfKey2 = (string)hashTable[\"key2\"];"
    },
    {
      "id": "s8-164",
      "sectionId": "s8",
      "title": "LINQ",
      "kind": "text",
      "body": "> C#语言中的LINQ（Language-Integrated Query）是一种强大的查询语言，它提供了一种统一的编程模型，使得数据查询变得更加直观和简洁。"
    },
    {
      "id": "s8-165",
      "sectionId": "s8",
      "title": "FROM",
      "kind": "text",
      "body": "> 任何数据源，包括对象集合、数据库、XML等。"
    },
    {
      "id": "s8-166",
      "sectionId": "s8",
      "title": "WHERE",
      "kind": "text",
      "body": "> 条件查询"
    },
    {
      "id": "s8-167",
      "sectionId": "s8",
      "title": "WHERE",
      "kind": "code",
      "lang": "cs",
      "code": "// 示例数据源\nList<Student> students = new List<Student>\n{\n    new Student { Name = \"Alice\", Age = 25, Grade = \"A\" },\n    new Student { Name = \"Bob\", Age = 30, Grade = \"B\" },\n    new Student { Name = \"Barry\", Age = 35, Grade = \"C\" },\n    new Student { Name = \"Charlie\", Age = 22, Grade = \"A\" },\n    new Student { Name = \"David\", Age = 21, Grade = \"C\" },\n    new Student { Name = \"Damon\", Age = 28, Grade = \"B\" },\n    new Student { Name = \"Echo\", Age = 18, Grade = \"C\" }\n};\n\n// 使用WHERE筛选出成绩为A的学生\nvar result1 = students.Where(student => student.Grade = \"A\");\n\n// 使用WHERE筛选出年龄大于20的学生\nvar result2 = students.Where(student => student.Age > 20);\n\n// 使用WHERE筛选出名字包含'D'的学生\nvar result3 = students.Where(student => student.Name.Contains(\"D\"));\n\n// 使用WHERE筛选出名字为'Bob'和'Echo'的学生\nList<string> nameList = new() { \"Bob\", \"Echo\" };\nvar result4 = students.Where(student => nameList.Contains(student.Name));"
    },
    {
      "id": "s8-168",
      "sectionId": "s8",
      "title": "GROUPBY",
      "kind": "text",
      "body": "> 分组查询"
    },
    {
      "id": "s8-169",
      "sectionId": "s8",
      "title": "GROUPBY",
      "kind": "code",
      "lang": "cs",
      "code": "// 示例数据源\nList<Student> students = new List<Student>\n{\n    new Student { Name = \"Alice\", Age = 25, Grade = \"A\" },\n    new Student { Name = \"Bob\", Age = 30, Grade = \"B\" },\n    new Student { Name = \"Barry\", Age = 35, Grade = \"C\" },\n    new Student { Name = \"Charlie\", Age = 22, Grade = \"A\" },\n    new Student { Name = \"David\", Age = 21, Grade = \"C\" },\n    new Student { Name = \"Damon\", Age = 28, Grade = \"B\" },\n    new Student { Name = \"Echo\", Age = 18, Grade = \"C\" }\n};\n\n// 使用GROUP BY按成绩进行分组查询\nvar groupedByGrade = students.GroupBy(student => student.Grade);"
    },
    {
      "id": "s8-170",
      "sectionId": "s8",
      "title": "SELECT",
      "kind": "text",
      "body": "> 结果查询"
    },
    {
      "id": "s8-171",
      "sectionId": "s8",
      "title": "SELECT",
      "kind": "code",
      "lang": "cs",
      "code": "// 示例数据源\nList<Student> students = new List<Student>\n{\n    new Student { Name = \"Alice\", Age = 25, Grade = \"A\" },\n    new Student { Name = \"Bob\", Age = 30, Grade = \"B\" },\n    new Student { Name = \"Barry\", Age = 35, Grade = \"C\" },\n    new Student { Name = \"Charlie\", Age = 22, Grade = \"A\" },\n    new Student { Name = \"David\", Age = 21, Grade = \"C\" },\n    new Student { Name = \"Damon\", Age = 28, Grade = \"B\" },\n    new Student { Name = \"Echo\", Age = 18, Grade = \"C\" }\n};\n\n// 使用SELECT创建一个新的匿名类，并输出为集合，一般配合Where使用\nvar result1 = students.Select(student => \n  new \n    {\n      student.Name,\n        student.Age\n    });\n\n// 使用SELECT创建一个新的指定类，并输出为集合\nvar result2 = students.Select(student => new StudentDto()\n    {\n        StudentName = student.Name,\n        StudentAge = student.Age\n    });"
    },
    {
      "id": "s8-172",
      "sectionId": "s8",
      "title": "ORDERBY",
      "kind": "text",
      "body": "> 排序"
    },
    {
      "id": "s8-173",
      "sectionId": "s8",
      "title": "ORDERBY",
      "kind": "code",
      "lang": "cs",
      "code": "// 示例数据源\nList<Student> students = new List<Student>\n{\n    new Student { Name = \"Alice\", Age = 25, Grade = \"A\" },\n    new Student { Name = \"Bob\", Age = 30, Grade = \"B\" },\n    new Student { Name = \"Barry\", Age = 35, Grade = \"C\" },\n    new Student { Name = \"Charlie\", Age = 22, Grade = \"A\" },\n    new Student { Name = \"David\", Age = 21, Grade = \"C\" },\n    new Student { Name = \"Damon\", Age = 28, Grade = \"B\" },\n    new Student { Name = \"Echo\", Age = 18, Grade = \"C\" }\n};\n\n// 使用LINQ的OrderBy进行排序\nvar result1 = students.OrderBy(student => student.Age);\n\n// 使用LINQ的OrderByDescending进行降序排序\nvar result2 = students.OrderByDescending(student => student.Age);"
    },
    {
      "id": "s8-174",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "text",
      "body": "• `Join`：用于执行内连接操作，它会返回两个数据源中满足连接条件的元素的交集\n• `GroupJoin`：用于执行左外连接（left outer join）操作，它会返回左边数据源的所有元素，以及每个元素所匹配的右边数据源的元素组成的集合。(嵌套)"
    },
    {
      "id": "s8-175",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "text",
      "body": "示例数据源"
    },
    {
      "id": "s8-176",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "code",
      "lang": "cs",
      "code": "List<Department> departments = new List<Department>\n{\n    new Department { ID = 1, Name = \"HR\" },\n    new Department { ID = 2, Name = \"IT\" }\n};"
    },
    {
      "id": "s8-177",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "text",
      "body": "示例数据源"
    },
    {
      "id": "s8-178",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "code",
      "lang": "cs",
      "code": "List<Employee> employees = new List<Employee>\n{\n    new Employee { DepartmentID = 1, Name = \"Alice\" },\n    new Employee { DepartmentID = 2, Name = \"Bob\" },\n    new Employee { DepartmentID = 1, Name = \"Charlie\" },\n    new Employee { DepartmentID = 3, Name = \"David\" }\n};"
    },
    {
      "id": "s8-179",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "text",
      "body": "使用 `Join`，将部门和员工相结合，获取部门名称和员工名称的集合"
    },
    {
      "id": "s8-180",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "code",
      "lang": "cs",
      "code": "var joinQuery = departments.Join(employees, \n    department => department.ID, employee => employee.DepartmentID, \n    (department, employee) => new { Department = department.Name, Employee = employee.Name }\n);"
    },
    {
      "id": "s8-181",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "text",
      "body": "使用 `GroupJoin`，将部门和员工相结合，返回所有的部门，并返回每个部门相关联的员工集合(嵌套)"
    },
    {
      "id": "s8-182",
      "sectionId": "s8",
      "title": "JOIN",
      "kind": "code",
      "lang": "cs",
      "code": "var groupJoinQuery = departments.GroupJoin(employees, \n    department => department.ID, employee => employee.DepartmentID, \n    (department, employeeGroup) => new \n        { \n            Department = department.Name, \n            Employees = employeeGroup.Select(e => e.Name).ToList() \n        }\n);"
    },
    {
      "id": "s8-183",
      "sectionId": "s8",
      "title": "结果转换",
      "kind": "code",
      "lang": "cs",
      "code": "// ToList(): 将结果转换为List集合。\nList<Student> resultList = result.ToList();\n\n// ToDictionary(): 将结果转换为Dictionary字典。\nDictionary<string, int> resultDictionary = students\n    .ToDictionary(student => student.Name, student => student.Age);\n\n// ToArray(): 将结果转换为数组。\nStudent[] resultArray = result.ToArray();\n\n// First(): 获取结果中的第一个元素。\nStudent firstStudent = result.First();\n\n// FirstOrDefault(): 获取结果中的第一个元素，如果结果为空则返回默认值。\nStudent firstStudent = result.FirstOrDefault();"
    },
    {
      "id": "s8-184",
      "sectionId": "s8",
      "title": "自定义扩展方法",
      "kind": "code",
      "lang": "cs",
      "code": "public static class CustomExtensions\n{\n    public static IEnumerable<T> CustomFilter<T>(this IEnumerable<T> source, Func<T, bool> predicate)\n    {\n        foreach (var item in source)\n        {\n            if (predicate(item))\n            {\n                yield return item;\n            }\n        }\n    }\n}\n// 使用自定义扩展方法\nvar filteredData = students.CustomFilter(s => s.Age > 20);"
    },
    {
      "id": "s8-185",
      "sectionId": "s8",
      "title": "示例",
      "kind": "text",
      "body": "假设有一个包含学生信息的列表，每个学生有姓名、年龄和成绩。使用LINQ查询来选择年龄大于20岁的学生，然后按照他们的成绩进行分组，并选择每个分组中年龄最小的学生的姓名。"
    },
    {
      "id": "s8-186",
      "sectionId": "s8",
      "title": "示例",
      "kind": "code",
      "lang": "cs",
      "code": "// 示例数据源\nList<Student> students = new List<Student>\n{\n    new Student { Name = \"Alice\", Age = 25, Grade = \"A\" },\n    new Student { Name = \"Bob\", Age = 30, Grade = \"B\" },\n    new Student { Name = \"Barry\", Age = 35, Grade = \"C\" },\n    new Student { Name = \"Charlie\", Age = 22, Grade = \"A\" },\n    new Student { Name = \"David\", Age = 21, Grade = \"C\" },\n    new Student { Name = \"Damon\", Age = 28, Grade = \"B\" },\n    new Student { Name = \"Echo\", Age = 18, Grade = \"C\" }\n};"
    },
    {
      "id": "s8-187",
      "sectionId": "s8",
      "title": "示例",
      "kind": "text",
      "body": "使用 `LINQ` 进行查询"
    },
    {
      "id": "s8-188",
      "sectionId": "s8",
      "title": "示例",
      "kind": "code",
      "lang": "cs",
      "code": "var result = students\n    .Where(student => student.Age > 20) // WHERE: 选择年龄大于20的学生\n    .GroupBy(student => student.Grade)  // GROUP BY: 按成绩分组\n    .Select(group => group.OrderBy(student => student.Age).First().Name) // SELECT: 选择每个分组中年龄最小的学生的姓名\n    .ToList(); //转换为List<Student>()"
    },
    {
      "id": "s8-189",
      "sectionId": "s8",
      "title": "示例",
      "kind": "text",
      "body": "输出结果"
    },
    {
      "id": "s8-190",
      "sectionId": "s8",
      "title": "示例",
      "kind": "code",
      "lang": "cs",
      "code": "[\"Charlie\",\"Damon\",\"David\"]"
    },
    {
      "id": "s9-191",
      "sectionId": "s9",
      "title": "介绍",
      "kind": "text",
      "body": "在 .NET 中，委托支持后期绑定，允许调用方在运行时提供方法的一部分，而不是在创建委托时定义完整算法，从而增强了灵活性和扩展性。"
    },
    {
      "id": "s9-192",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "我们预先提供这些可用的方法"
    },
    {
      "id": "s9-193",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "public void Sub(int x, int y)\n{\n    Console.WriteLine(\"x-y=\" + (x - y));\n}\n\npublic void Mul(int x, int y)\n{\n    Console.WriteLine(\"x*y=\" + (x * y));\n}"
    },
    {
      "id": "s9-194",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "定义一个委托类型"
    },
    {
      "id": "s9-195",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "public delegate void MyDelegate3(int x, int y);"
    },
    {
      "id": "s9-196",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "定义一个方法，接收委托作为参数"
    },
    {
      "id": "s9-197",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "public void MyMethod3(int x, int y, MyDelegate3 myDelegate)\n{\n    myDelegate(x, y);\n}"
    },
    {
      "id": "s9-198",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "定义另一个委托类型"
    },
    {
      "id": "s9-199",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "public delegate void MyDelegate4(int x, int y);"
    },
    {
      "id": "s9-200",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "定义一个方法，接收委托作为参数"
    },
    {
      "id": "s9-201",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "public void MyMethod4(int x, int y, MyDelegate4 myDelegate)\n{\n    myDelegate(x, y);\n}"
    },
    {
      "id": "s9-202",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "定义一个方法，接收委托作为参数"
    },
    {
      "id": "s9-203",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "public void MyMethod5(int x, int y, MyDelegate3 myDelegate, MyDelegate4 myDelegate2)\n{\n    myDelegate(x, y);\n    myDelegate2(x, y);\n}"
    },
    {
      "id": "s9-204",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "#### 多播委托"
    },
    {
      "id": "s9-205",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "MyDelegate3 myDelegate31 = new MyDelegate3(Sub);\nMyDelegate4 myDelegate41 = new MyDelegate4(Mul);"
    },
    {
      "id": "s9-206",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "调用 MyMethod3 方法，并传入委托作为参数"
    },
    {
      "id": "s9-207",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "MyMethod3(10, 5, myDelegate31);\n// output:\n// x-y=5"
    },
    {
      "id": "s9-208",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "调用 MyMethod4 方法，并传入委托作为参数"
    },
    {
      "id": "s9-209",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "MyMethod4(10, 5, myDelegate41);\n// output:\n// x*y=50"
    },
    {
      "id": "s9-210",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "text",
      "body": "调用 MyMethod5 方法，并传入委托作为参数"
    },
    {
      "id": "s9-211",
      "sectionId": "s9",
      "title": "多播委托",
      "kind": "code",
      "lang": "cs",
      "code": "MyMethod5(10, 5, myDelegate31, myDelegate41);\n// output:\n// x-y=5\n// x*y=50"
    },
    {
      "id": "s9-212",
      "sectionId": "s9",
      "title": "定义委托类型",
      "kind": "text",
      "body": "使用 `delegate` 关键字定义委托"
    },
    {
      "id": "s9-213",
      "sectionId": "s9",
      "title": "定义委托类型",
      "kind": "code",
      "lang": "cs",
      "code": "public delegate void MyDelegate(\n    int x, string y\n);"
    },
    {
      "id": "s9-214",
      "sectionId": "s9",
      "title": "定义委托类型",
      "kind": "text",
      "body": "上述委托对应的函数实现应该类似:"
    },
    {
      "id": "s9-215",
      "sectionId": "s9",
      "title": "定义委托类型",
      "kind": "code",
      "lang": "cs",
      "code": "public void MyMethod(int x, string y);"
    },
    {
      "id": "s9-216",
      "sectionId": "s9",
      "title": "创建委托实例",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建委托实例\nMyDelegate myDelegate = new MyDelegate(\n    MyMethod\n);"
    },
    {
      "id": "s9-217",
      "sectionId": "s9",
      "title": "调用委托",
      "kind": "code",
      "lang": "cs",
      "code": "// 调用委托,传入对应类型的参数\nmyDelegate(10, \"Hello\");"
    },
    {
      "id": "s9-218",
      "sectionId": "s9",
      "title": "委托作为参数",
      "kind": "code",
      "lang": "cs",
      "code": "// 定义另一个委托类型\npublic delegate int MyDelegate2(\n    int x, int y\n);\n\n// 定义一个方法，接收委托作为参数\npublic int MyMethod2(\n   int x, int y, MyDelegate2 myDelegate\n)\n{\n    return myDelegate(x, y);\n}\n\n// 创建委托实例\nMyDelegate2 myDelegate2 = new MyDelegate2(\n    Add\n);\n\n// 调用 MyMethod2 方法，并传入委托作为参数\nint result = MyMethod2(\n    10, 20, myDelegate2\n);"
    },
    {
      "id": "s9-219",
      "sectionId": "s9",
      "title": "Action 委托",
      "kind": "text",
      "body": "Action 委托的变体最多可包含 16 个参数，且返回类型为 `void`"
    },
    {
      "id": "s9-220",
      "sectionId": "s9",
      "title": "Action 委托",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建一个Action\npublic Action<int, string> myAction;\n\n// 给Action赋值\nmyAction = (x, y) => Console.WriteLine(\n    \"x+y=\" + (x + y)\n);\n\n// 直接调用Action\nmyAction(10, \"Hello\");\n\n// 使用 null 合并运算符调用Action\nmyAction?.Invoke(10, \"Hello\");"
    },
    {
      "id": "s9-221",
      "sectionId": "s9",
      "title": "Func 委托",
      "kind": "text",
      "body": "Func 委托的变体可包含最多16个参数，返回类型可以是任意类型 T"
    },
    {
      "id": "s9-222",
      "sectionId": "s9",
      "title": "Func 委托",
      "kind": "code",
      "lang": "cs",
      "code": "// 创建一个Func,最后一个参数是返回类型\npublic Func<int, int, string> myFunc;\n\n// 给Func赋值\nmyFunc = (x, y) => \"x+y=\" + (x + y);\n\n// 调用Func\nstring result = myFunc(10, 20);\n\n// 使用 null 合并运算符调用Func\nstring result2 = myFunc?.Invoke(10, 20);"
    },
    {
      "id": "s9-223",
      "sectionId": "s9",
      "title": "Func 委托",
      "kind": "text",
      "body": "事件与委托类似，都是后期绑定机制。实际上，事件是建立在委托基础上的一种语言支持，它是 C# 对委托的封装，提供了更面向对象的编程模型，并实现了观察者模式。"
    },
    {
      "id": "s9-224",
      "sectionId": "s9",
      "title": "事件定义",
      "kind": "code",
      "lang": "cs",
      "code": "// 使用 event 关键字定义事件\npublic event EventHandler<EventArgs> MyEvent;"
    },
    {
      "id": "s9-225",
      "sectionId": "s9",
      "title": "事件订阅",
      "kind": "text",
      "body": "我们实现定义一个方法作为事件处理器，并订阅事件"
    },
    {
      "id": "s9-226",
      "sectionId": "s9",
      "title": "事件订阅",
      "kind": "code",
      "lang": "cs",
      "code": "public void MyEventHandler(object sender, EventArgs e)\n{\n    // 事件处理逻辑\n    // ...\n}"
    },
    {
      "id": "s9-227",
      "sectionId": "s9",
      "title": "事件订阅",
      "kind": "code",
      "lang": "cs",
      "code": "// 订阅事件\nMyEvent += MyEventHandler;\n\n// 取消订阅事件\nMyEvent -= MyEventHandler;"
    },
    {
      "id": "s9-228",
      "sectionId": "s9",
      "title": "事件触发",
      "kind": "code",
      "lang": "cs",
      "code": "// 触发事件\nMyEvent?.Invoke(this, new EventArgs());"
    },
    {
      "id": "s9-229",
      "sectionId": "s9",
      "title": "事件参数",
      "kind": "code",
      "lang": "cs",
      "code": "// 定义事件参数\npublic class MyEventArgs : EventArgs\n{\n    public int Value { get; set; }\n}\n\n// 新的Handler\npublic void MyEventHandler2(object sender, MyEventArgs e)\n{\n    // 事件处理逻辑,这里可以获取到事件参数\n    Console.WriteLine(\"事件参数的值：\" + e.Value);\n}\n\n// 触发事件\n// output:\n// 事件参数的值：10\nMyEvent?.Invoke(this, new MyEventArgs { Value = 10 });"
    },
    {
      "id": "s10-230",
      "sectionId": "s10",
      "title": "语法糖",
      "kind": "text",
      "body": "> 语法糖需要根据 `c#` 版本来确实是否可以使用，一般情况下 `c# 8.0` 及以上的 `C#` 版本都已支持。"
    },
    {
      "id": "s10-231",
      "sectionId": "s10",
      "title": "对象判空及赋值",
      "kind": "code",
      "lang": "cs",
      "code": "// 判断对象是否为空，为空抛出异常\nif(obj == null) throw new NullReferenceException();\n\n// 简化的语法糖\nobj ?? throw new NullReferenceException();\n\n// 判断 对象为空 的情况下再赋新值\n//     对象不为空 不进行赋值\nif(obj == null)\n{\n  obj = new object();\n}\n\n// 简化的语法糖\nobj ??= new object();"
    },
    {
      "id": "s10-232",
      "sectionId": "s10",
      "title": "可空类型判空及赋值",
      "kind": "code",
      "lang": "cs",
      "code": "// 可空类型\nint? nums = null;\n\n// 判断值是否为空，并进行不同的赋值\nif(nums == null)\n{\n  result = -1;\n} \nelse \n{\n  result = nums;\n}\n\n// 简化的语法糖\nint result = nums ?? -1;"
    },
    {
      "id": "s10-233",
      "sectionId": "s10",
      "title": "减少空引用",
      "kind": "text",
      "body": "判断数组或 `list` 不能 `null` 且有元素"
    },
    {
      "id": "s10-234",
      "sectionId": "s10",
      "title": "减少空引用",
      "kind": "code",
      "lang": "cs",
      "code": "if(list != null && list.Count > 0)"
    },
    {
      "id": "s10-235",
      "sectionId": "s10",
      "title": "减少空引用",
      "kind": "text",
      "body": "简化的语法糖当 `list` 为 `null` 时，将直接返回 `false`"
    },
    {
      "id": "s10-236",
      "sectionId": "s10",
      "title": "减少空引用",
      "kind": "code",
      "lang": "cs",
      "code": "if(list?.Count > 0)"
    },
    {
      "id": "s10-237",
      "sectionId": "s10",
      "title": "减少空引用",
      "kind": "text",
      "body": "同样可运用在赋值时，如果 `obj` 为 `null`，将不会取 `obj.text` 的值，而是将会为 `text` 赋值 `null`"
    },
    {
      "id": "s10-238",
      "sectionId": "s10",
      "title": "减少空引用",
      "kind": "code",
      "lang": "cs",
      "code": "string text = obj?.text;"
    },
    {
      "id": "s10-239",
      "sectionId": "s10",
      "title": "判断参数类型并转换类型+校验",
      "kind": "text",
      "body": "• 判断 `value` 是否为 `string` 类型，如果 `value` 是 `string` 类型\n• 那么将 `value` 转换为 `string` 类型，并赋值给 `stringValue`\n• 再判断 `stringValue` 是否不为 `Null` 或 `空`"
    },
    {
      "id": "s10-240",
      "sectionId": "s10",
      "title": "判断参数类型并转换类型+校验",
      "kind": "code",
      "lang": "cs",
      "code": "if(value is string stringValue && !string.IsNullOrEmpty(stringValue))"
    },
    {
      "id": "s10-241",
      "sectionId": "s10",
      "title": "Switch",
      "kind": "code",
      "lang": "cs",
      "code": "public string GetNums(int num)\n{\n  // 使用这种方式的switch时，要求返回类型统一\n  string str = num switch\n  {\n    1 => \"num的值是1\",\n    2 => \"num的值是2\",\n    3 => \"num的值是3\",\n    4 => \"num的值是4\",\n    _ => \"其他\"\n  };\n\n  return str;\n}"
    },
    {
      "id": "s10-242",
      "sectionId": "s10",
      "title": "切片操作",
      "kind": "code",
      "lang": "cs",
      "code": "// **以下所有[]中的数字都代表索引**\n// **如果是范围索引，且声明结束索引，那么都将不包含结束索引的值**\n\n// 数组例子\nstring[] arr = new string[] { \"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\", \"100\" };\n\n// 获取最后一个元素\nstring str = arr[^1];\n\n// 获取前3个元素，从索引0开始 到 索引3(不包含)：[\"10\",\"20\",\"30\"]\n// 可省略索引0，从开始 到 索引3(不包含)\n// string[] strs = arr[..3];\nstring[] strs1 = arr[0..3];\n\n// 获取后3个元素，从倒数第3个元素开始 到 最后：[\"80\", \"90\", \"100\"]\n// 最后一位索引被省略 string[] strs21 = arr[^3..^0];\n// ^0 倒数第0个元素是不存在的\nstring[] strs2 = arr[^3..];\n\n// 指定获取 正向 某一段元素\n// 从索引3开始 到 索引7(不包含)：[\"40\", \"50\", \"60\", \"70\"]\nstring[] strs3 = arr[3..7];\n\n// 指定获取 反向 某一段元素\n// 倒数第4个元素开始 到 倒数第2个元素(不包含)：[\"70\",\"80\"]\nstring[] strs4 = arr[^4..^2];"
    },
    {
      "id": "s11-243",
      "sectionId": "s11",
      "title": "常用 .NET 概念",
      "kind": "text",
      "body": "概念 | 中文名 | 定义\n:- | -|--\n`Runtime` | 运行时 | 执行给定的已编译代码单元所需的服务集合\n`Common Language Runtime (CLR)` | 通用语言运行库 | 主要定位、加载和托管 .NET 对象。<br/>CLR 还处理内存管理、应用程序托管、线程协调、执行安全检查和其他低级细节\n`Managed code` | 托管代码 | 在 `.NET` 运行时编译和运行的代码。 C#/F#/VB 就是例子\n`Unmanaged code` | 非托管代码 | 直接编译为机器代码且不能由 .NET 运行时直接托管的代码。<br/>不包含空闲内存管理、垃圾收集等。从 C/C++ 创建的 DLL 就是示例\n<!--rehype:className=show-header left-align-->"
    }
  ],
  "source": {
    "repo": "https://github.com/jaywcjlove/reference",
    "path": "docs/cs.md",
    "ref": "main",
    "url": "https://github.com/jaywcjlove/reference/tree/main/docs/cs.md",
    "lang": "zh",
    "mode": "local"
  }
}