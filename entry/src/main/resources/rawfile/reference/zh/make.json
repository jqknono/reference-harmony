{
  "id": "make",
  "name": "make 备忘清单",
  "title": "包含 最重要概念、函数、方法等的 make 备忘单。 初学者的完整快速参考。",
  "icon": "https://raw.githubusercontent.com/jaywcjlove/reference/main/assets/make.svg",
  "sections": [
    {
      "id": "intro",
      "title": "简介",
      "startIndex": 0
    },
    {
      "id": "s1",
      "title": "Makefile 入门",
      "startIndex": 1
    },
    {
      "id": "s2",
      "title": "变量",
      "startIndex": 21
    },
    {
      "id": "s3",
      "title": "书写规则",
      "startIndex": 54
    },
    {
      "id": "s4",
      "title": "命令",
      "startIndex": 72
    },
    {
      "id": "s5",
      "title": "判断和循环",
      "startIndex": 86
    },
    {
      "id": "s6",
      "title": "函数",
      "startIndex": 95
    },
    {
      "id": "s7",
      "title": "另见",
      "startIndex": 162
    }
  ],
  "cards": [
    {
      "id": "intro-0",
      "sectionId": "intro",
      "title": "简介",
      "body": "包含 最重要概念、函数、方法等的 make 备忘单。 初学者的完整快速参考。"
    },
    {
      "id": "s1-1",
      "sectionId": "s1",
      "title": "示例",
      "body": "```makefile\na.txt: b.txt c.txt\n\tcat b.txt c.txt > a.txt\n```"
    },
    {
      "id": "s1-2",
      "sectionId": "s1",
      "title": "工作流程",
      "body": "• 读入所有的 `Makefile`。\n• 读入被 `include` 的其它 `Makefile`。\n• 初始化文件中的变量。\n• 推导隐晦规则，并分析所有规则。\n• 为所有的目标文件创建依赖关系链。\n• 根据依赖关系，决定哪些目标要重新生成。\n• 执行生成命令。"
    },
    {
      "id": "s1-3",
      "sectionId": "s1",
      "title": "文件命令",
      "body": "make命令会以 `GNUmakefile`（不推荐使用）、`makefile`、`Makefile`（推荐使用）的顺序查找当前目录下的文件。"
    },
    {
      "id": "s1-4",
      "sectionId": "s1",
      "title": "自定义文件路径",
      "body": "```bash\n$ make target -f FILE\n```\n\n我们可以使用 `-f FILE` 来指定makefile文件的路径"
    },
    {
      "id": "s1-6",
      "sectionId": "s1",
      "title": "隐式生成",
      "body": "如果文件夹中没有 makefile 文件，只有 main.c 源文件，那么我们可以使用 `make main.o` 隐式生成链接文件\n\n```bash\n$ make main.o\n# 实际执行： cc    -c -o main.o main.c\n```"
    },
    {
      "id": "s1-8",
      "sectionId": "s1",
      "title": "%E8%A7%84%E5%88%99",
      "body": "%60%60%60makefile%0ATARGET%3A%20PREREQUISITES%0A%20%20COMMAMD%0A...%0A%60%60%60%0A%0A%E2%80%A2%20%60target%60%3A%20%E8%A7%84%E5%88%99%E7%9A%84%E7%9B%AE%E6%A0%87%E3%80%82%E7%9B%AE%E6%A0%87%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%A7%84%E5%88%99%E7%9A%84%E5%8A%A8%E4%BD%9C%EF%BC%88%E5%A6%82%20%60clean%60%20%E7%AD%89%EF%BC%89%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E6%9C%80%E5%90%8E%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E3%80%82%0A%E2%80%A2%20%60prerequisites%60%3A%20%E8%A7%84%E5%88%99%E7%9A%84%E4%BE%9D%E8%B5%96%E3%80%82%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E5%88%97%E8%A1%A8%EF%BC%88%E9%80%9A%E5%B8%B8%E4%B8%80%E4%B8%AA%E7%9B%AE%E6%A0%87%E4%BE%9D%E8%B5%96%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%88%96%E8%80%85%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%89%E3%80%82%0A%E2%80%A2%20%60command%60%3A%20%E8%A7%84%E5%88%99%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E3%80%82%E8%A7%84%E5%88%99%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8A%A8%E4%BD%9C%EF%BC%88%E4%BB%BB%E6%84%8F%E7%9A%84%20shell%20%E5%91%BD%E4%BB%A4%E6%88%96%E8%80%85%E5%9C%A8%20shell%20%E4%B8%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%89%E3%80%82%3Cspan%20style%3D%22color%3Ared%22%3E%E5%91%BD%E4%BB%A4%E9%9C%80%E8%A6%81%E4%BB%A5%20tab%20%E9%94%AE%E5%BC%80%E5%A4%B4%3C%2Fspan%3E%0A%0A%60%60%60bash%0A%24%20make%20%5BTARGET%20...%5D%0A%60%60%60%0A%0A%60%60%60bash%0A%24%20make%20%20%20%20%20%20%20%20%23%20%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E9%A6%96%E5%85%88%E8%BF%90%E8%A1%8C%20TARGET%0A%24%20make%20help%20%20%20%23%20%E6%98%BE%E7%A4%BA%E5%8F%AF%E7%94%A8%E7%9B%AE%E6%A0%87%0A%24%20make%20dist%20%20%20%23%20%E4%BB%8E%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%8F%91%E5%B8%83%E5%AD%98%E6%A1%A3%0A%24%20make%20check%20%20%23%20%E6%97%A0%E9%9C%80%E5%AE%89%E8%A3%85%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%0A%60%60%60",
      "encoded": true
    },
    {
      "id": "s1-11",
      "sectionId": "s1",
      "title": "%E6%B8%85%E7%A9%BA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6",
      "body": "%60%60%60makefile%0A.PHONY%3A%20clean%0Aclean%3A%0A%20%20rm%20*.o%20temp%0A%60%60%60%0A%0A%60.PHONY%60%20%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E5%B0%86%E6%8E%92%E9%99%A4%20clean%20%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%9B%A0%E4%B8%BA%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%9B%A0%E4%B8%BA%E6%9C%89%20clean%20%E6%96%87%E4%BB%B6%E8%80%8C%E4%B8%8D%E4%BC%9A%E4%B8%8D%E6%89%A7%E8%A1%8C%20clean%20%E4%BC%AA%E7%9B%AE%E6%A0%87%0A%0A%3Cspan%20style%3D%22color%3Ared%22%3Eclean%20%E4%BB%8E%E6%9D%A5%E9%83%BD%E6%98%AF%E6%94%BE%E5%9C%A8%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E5%90%8E%3C%2Fspan%3E",
      "encoded": true
    },
    {
      "id": "s1-14",
      "sectionId": "s1",
      "title": "注释",
      "body": "makefile 文件的注释与 bash 脚本一致\n\n```makefile\n# 这是一个注释\nmain.o : main.c\n\tcc -c main.c\n```"
    },
    {
      "id": "s1-16",
      "sectionId": "s1",
      "title": "换行 `\\`",
      "body": "```makefile\n# 这是一个注释\nmain.o : main.c\n\tcc -c \\\n\tmain.c\n```"
    },
    {
      "id": "s1-17",
      "sectionId": "s1",
      "title": "引用其它的 Makefile",
      "body": "`include` 关键字可以把别的 Makefile 包含进来。这样使用 make 运行的时候就会\n\n```makefile\n# makefile\ninclude foo.make\n```\n\n如果你想让 make 不理那些无法读取的文件，并且继续执行。\n\n```makefile\n-include <filename>\n```"
    },
    {
      "id": "s2-21",
      "sectionId": "s2",
      "title": "赋值符 - 在执行时扩展，允许递归扩展",
      "body": "```makefile\nVARIABLE = value\n```"
    },
    {
      "id": "s2-22",
      "sectionId": "s2",
      "title": "在声明时扩展",
      "body": "可以防止递归，并且只能引用之前声明过的变量\n\n```makefile\nVARIABLE := value\n```"
    },
    {
      "id": "s2-24",
      "sectionId": "s2",
      "title": "只有在该变量为空时才设置值",
      "body": "```makefile\nVARIABLE ?= value\n```"
    },
    {
      "id": "s2-25",
      "sectionId": "s2",
      "title": "将值追加到变量的尾端",
      "body": "```makefile\nVARIABLE += value\n```"
    },
    {
      "id": "s2-26",
      "sectionId": "s2",
      "title": "override",
      "body": "如果变量前不指定 `override`，那么命令行中指定的变量可以对 Makefile 中的变量重新定义。\n\n```makefile\n# 不会重新定义\noverride VARIABLE = value\noverride VARIABLE := value\noverride VARIABLE ?= value\noverride VARIABLE += value\noverride define\n  #...\nendef\n```"
    },
    {
      "id": "s2-28",
      "sectionId": "s2",
      "title": "变量",
      "body": "需要使用 `$()` 或者 `${}` 对变量进行引用\n\n```makefile\nfile = main.c\n\nrun:\n\tclang -o hello ${file}\n```"
    },
    {
      "id": "s2-30",
      "sectionId": "s2",
      "title": "避免递归变量",
      "body": "```makefile\n# 这样会使变量陷入无穷递归\nA = $(B)\nB = $(A)\n```\n\n```makefile\nx := foo\ny := $(x) bar\nx := later\n\n# 等价于\n# x = later\n# y = foo bar\n```"
    },
    {
      "id": "s2-31",
      "sectionId": "s2",
      "title": "Shell 变量",
      "body": "如果要使用 Shell 变量，需要在之前加上 `$`\n\n```makefile\nrun:\n\techo $$HOME\n```"
    },
    {
      "id": "s2-33",
      "sectionId": "s2",
      "title": "定义多行变量",
      "body": "```makefile\ndefine foo\necho foo\necho bar\nendef\n\nrun:\n\t${foo}\n```"
    },
    {
      "id": "s2-34",
      "sectionId": "s2",
      "title": "自动变量 - `$@`",
      "body": "`$@`:指代当前目标，即 Make 命令当前构建的那个目标\n\n```makefile\nfoo:\n\ttouch $@\n```\n\n```bash\n$ make foo\n# $@ 就是指的这里的 foo\n```"
    },
    {
      "id": "s2-36",
      "sectionId": "s2",
      "title": "`$<`",
      "body": "`$<` 指代第一个前置条件。比如，规则为 t: p1 p2，那么 `$<` 就指代 p1\n\n```makefile\na.md: b.md c.md\n  cp $< $@\n```\n\n使用 `make a.md`,相当于以下写法\n\n```makefile\na.md: b.md c.md\n    cp b.md a.md \n```"
    },
    {
      "id": "s2-40",
      "sectionId": "s2",
      "title": "`$^`",
      "body": "`$^` 指代所有的前置条件,去除重复项\n\n```makefile\na.md: b.md c.md\n  echo $^\n```"
    },
    {
      "id": "s2-42",
      "sectionId": "s2",
      "title": "`$+`",
      "body": "`$^` 指代所有的前置条件，不会去除重复项\n\n```makefile\na.md: b.md c.md c.md\n\techo $+\n```"
    },
    {
      "id": "s2-44",
      "sectionId": "s2",
      "title": "`$?`",
      "body": "`$?` 指代更新的依赖，只有最近更新过的依赖才会引用\n\n```makefile\na.md: b.md c.md c.md\n\tcat $? > a.md\n```"
    },
    {
      "id": "s2-46",
      "sectionId": "s2",
      "title": "`$*`",
      "body": "`$*` 指代匹配符匹配的部分\n\n```makefile\nmain.o: main.c\n\tclang -o $* $*.c\n```\n\n```bash\n$ make main\n# 此时 cc  main.c -o main\n```"
    },
    {
      "id": "s2-48",
      "sectionId": "s2",
      "title": "`$%`",
      "body": "`$%`: 仅当目标是函数库文件中，表示规则中的目标成员名\n\n• windows 中是 `.lib` 文件\n• unix 中是 `.a` 文件"
    },
    {
      "id": "s2-50",
      "sectionId": "s2",
      "title": "内置命名变量的参数",
      "body": "这些变量都是相关下面的命令的参数。如果没有指明其默认值，那么其默认值都是空。\n\n:-       | :-\n:-       | :-\n`ARFLAGS`  | 函数库打包程序AR命令的参数。默认值是 `rv`\n`ASFLAGS`  | 汇编语言编译器参数。（当明显地调用 `.s` 或 `.S` 文件时）\n`CFLAGS`   | C 语言编译器参数。\n`CXXFLAGS` | C++ 语言编译器参数。\n`COFLAGS`  | RCS 命令参数。\n`CPPFLAGS` | C 预处理器参数。（ `C` 和 `Fortran` 编译器也会用到）。\n`FFLAGS`   | Fortran 语言编译器参数。\n`GFLAGS`   | SCCS `get` 程序参数。\n`LDFLAGS`  | 链接器参数。（如：`ld` ）\n`PFLAGS`   | Pascal 语言编译器参数。\n`LFLAGS`   | Lex 文法分析器参数。\n`RFLAGS`   | Ratfor 程序的 Fortran 编译器参数。\n`YFLAGS`   | Yacc 文法分析器参数。\n<!--rehype:className=left-align-->"
    },
    {
      "id": "s2-52",
      "sectionId": "s2",
      "title": "内置已命名的变量",
      "body": ":-         | :-\n:-         | :-\n`AR`       | 函数库打包程序。默认命令是 `ar`\n`AS`       | 汇编语言编译程序。默认命令是 `as`\n`CC`       | C 语言编译程序。默认命令是 `cc`\n`CXX`      | C++ 语言编译程序。默认命令是 `g++`\n`CO`       | 从 RCS 文件中扩展文件程序。默认命令是 `co`\n`CPP`      | C 程序的预处理器（输出是标准输出设备）。默认命令是 `$(CC) –E`\n`FC`       | Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 `f77`\n`GET`      | 从 SCCS 文件中扩展文件的程序。默认命令是 `get`\n`LEX`      | Lex 方法分析器程序（针对于 C 或 Ratfor）。默认命令是 `lex`\n`PC`       | Pascal 语言编译程序。默认命令是 `pc`\n`YACC`     | Yacc 文法分析器（针对于 C 程序）。默认命令是 `yacc`\n`YACCR`    | Yacc 文法分析器（针对于 Ratfor 程序）。默认命令是 `yacc –r`\n`MAKEINFO` | 转换 Texinfo 源文件（.texi）到 Info 文件程序。默认命令是 `makeinfo`\n`TEX`      | 从 TeX 源文件创建TeX DVI文件的程序。默认命令是 `tex`\n`TEXI2DVI` | 从 Texinfo 源文件创建 TeX DVI 文件的程序。默认命令是 `texi2dvi`\n`WEAVE`    | 转换 Web 到 TeX 的程序。默认命令是 `weave`\n`CWEAVE`   | 转换 C Web 到 TeX 的程序。默认命令是 `cweave`\n`TANGLE`   | 转换 Web 到 Pascal 语言的程序。默认命令是 `tangle`\n`CTANGLE`  | 转换 C Web 到 C。默认命令是 `ctangle`\n`RM`       | 删除文件命令。默认命令是 `rm –f`\n<!--rehype:className=left-align-->"
    },
    {
      "id": "s2-53",
      "sectionId": "s2",
      "title": "内置的变量",
      "body": "```makefile\nrun:\n\t${CC} -o main main.c\n```"
    },
    {
      "id": "s3-54",
      "sectionId": "s3",
      "title": "文件搜寻（`vpath`）",
      "body": "如果没有指定 vpath 变量，make 只会在当前的目录中去寻找依赖文件和目标文件。否则，如果当前目录没有，就会到指定的目录中去寻找\n\n:-                              | :-\n:-                              | :-\n`vpath <pattern> <directories>` | 为符合模式 \\<pattern> 的文件指定搜索目录 \\<directories>\n`vpath <pattern>`               | 清除符合模式 \\<pattern> 的文件的搜索目录。\n`vpath`                         | 清除所有已被设置好了的文件搜索目录"
    },
    {
      "id": "s3-56",
      "sectionId": "s3",
      "title": "`%`",
      "body": "• vpath 使用方法中的 \\<pattern> 需要包含 `%` 字符。`%` 的意思是匹配零或若干字符（类似于**通配符**）,并且引用规则是需要使用**自动变量**\n\n```makefile\nvpath %.c dist\nTARGET = hello\nOBJ = bar.o foo.o\n\n$(TARGET): $(OBJ)\n\t$(CC) -o $@ $^\n\n%.o: $.c\n\t$(CC) -o $< -o #@\n```"
    },
    {
      "id": "s3-58",
      "sectionId": "s3",
      "title": "通配符 - `*`",
      "body": "`*`：与 linux 系统下的一样\n\n```makefile\n# 清除所有 .o 结尾的文件\nclean:\n    rm -f *.o\n```"
    },
    {
      "id": "s3-60",
      "sectionId": "s3",
      "title": "`~`",
      "body": "`~`：在 linux 或 mac 下表示用户目录，win 下表示 `HOME` 环境变量\n\n```makefile\nrun:\n    ls ~\n```"
    },
    {
      "id": "s3-62",
      "sectionId": "s3",
      "title": "`?`",
      "body": "`?`: 与在 linux 等类似，可以匹配单个字符\n\n```makefile\nrun:\n\tls -ll packag?.json\n```"
    },
    {
      "id": "s3-64",
      "sectionId": "s3",
      "title": "静态模式",
      "body": "```makefile\nTARGET: PREREQUISITES :PREREQUISITES\n  COMMAMD\n#...\n```\n\n• `target` 定义了一系列的目标文件\n• 第一个 `prerequisites` 是指明了 target 的模式，也就是的目标集模式。\n• 第二个 `prerequisites` 是目标的依赖模式，它对第一个 `prerequisites` 形成的模式再进行一次依赖目标的定义\n\n```makefile\nobjects = foo.o main.o\n\n$(objects): %.o: %.c\n\t$(CC) -c $(CFLAGS) $< -o $@\n```\n\n相当于:\n\n```makefile\nfoo.o : foo.c\n    $(CC) -c $(CFLAGS) foo.c -o foo.o\nmain.o : main.c\n    $(CC) -c $(CFLAGS) main.c -o main.o\n```"
    },
    {
      "id": "s3-69",
      "sectionId": "s3",
      "title": "伪目标",
      "body": "• **伪目标**并不是一个文件，只是一个标签。只有通过显式地指明这个**目标**才能让其生效\n• 使用 `.PHONY` 来显式地指明目标是 `伪目标`\n\n```makefile\n.PHONY : clean\nclean :\n    rm *.o temp\n```"
    },
    {
      "id": "s3-71",
      "sectionId": "s3",
      "title": "约定俗成的规则",
      "body": ":-  | :-\n:-  | :-\n`all`        | 该伪目标是所有目标的目标，一般用于编译所有的目标\n`clean`      | 该伪目标用于删除所有由 make 创建的文件\n`install`    | 该伪目标用于安装已编译好的程序，即将目标执行文件拷贝到指定目标中\n`print`      | 该伪目标用于例出改变过的源文件\n`tar`        | 该伪目标用于把源程序打包备份为 tar 文件\n`dist`       | 该伪目标用于创建压缩文件，一般将 tar 文件压成 Z 或 gz 文件\n`TAGS`       | 该伪目标用于更新所有的目标，以备完整地重编译使用\n`check/test` | 这两个伪目标用于测试 makefile 的流程"
    },
    {
      "id": "s4-72",
      "sectionId": "s4",
      "title": "回声（`@`）",
      "body": "正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）\n\n```makefile\nall:\n  # 会有命令执行显示\n\techo Hello, world\n```\n\n```makefile\nall:\n  # 不会有命令执行的显示\n\t@echo Hello, world\n```"
    },
    {
      "id": "s4-74",
      "sectionId": "s4",
      "title": "显示命令、禁止命令 - 显示命令",
      "body": "如果我们只希望显示命令，而不希望执行命令，可以使用 `-n` 或者 `--just-print`\n\n```bash\n$ make all --just-print \n$ make all -n \n```"
    },
    {
      "id": "s4-76",
      "sectionId": "s4",
      "title": "禁止命令",
      "body": "`-s` 或 `--silent` 或 `--quiet` 与 `@` 一样，用于禁止回声\n\n```bash\n$ make all -s \n```"
    },
    {
      "id": "s4-78",
      "sectionId": "s4",
      "title": "执行命令",
      "body": "使用 tab 及换行\n\n```makefile\nexec:\n    cd /home/hchen\n    pwd\n```\n\n使用 `;`\n\n```makefile\nexec:\n    cd /home/hchen; pwd\n```"
    },
    {
      "id": "s4-82",
      "sectionId": "s4",
      "title": "make 参数",
      "body": ":-  | :-\n:-  | :-\n`-b`,`-m`     |  忽略和其它版本make的兼容性\n`-B`          |  (`--always-make`) 认为所有的目标都需要重编译\n`-C <dir>`    |  (`--directory=<dir>`) 指定读取makefile的目录\n`-e`          |  (`--environment-overrides`) 指明环境变量的值覆盖 makefile 中定义的变量的值\n`-f=<file>`   | 指定需要执行的makefile\n`-h`          | 显示帮助信息\n`-i`          | (`--ignore-errors`)在执行时忽略所有的错误\n`-I <dir>`    | (`--include-dir=<dir>`) 指定一个被包含 makefile 的搜索目标\n`-j [<nums>]` | (`--jobs[=<jobsnum>]`)指同时运行命令的个数\n`-k`          | (`--keep-going`)出错也不停止运行\n`-l <load>`   | `--load-average[=<load>]`、`-max-load[=<load>]` 指定make运行命令的负载\n`-n`          | (`--just-print`, `--dry-run`, `--recon`) 仅输出执行过程中的命令序列，但不执行\n`-o <file>`   | (`--old-file=<file>`, `--assume-old=<file>`)不重新生成的指定的 \\<file>，即使目标的依赖文件新于它\n`-p`          | (`--print-data-base`) 输出 makefile 中的所有数据，包括所有的规则和变量\n`-q`          | (`--question`) 不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新\n`-r`          | (`--no-builtin-rules`) 禁止 make 使用任何隐含规则\n`-R`          | (`--no-builtin-variabes`) 禁止 make 使用任何作用于变量上的隐含规则\n`-s`          | (`--silent`,`--quiet`) 在命令运行时不输出命令的输出\n`-S`          | (`--no-keep-going`, `--stop`) 取消“-k”选项的作用\n`-t`          | `--touch` 相当于 UNIX 的 touch 命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行\n`-v`          | (`--version`) 输出 make 程序的版本、版权等关于 make 的信息\n`-w`          | (`--print-directory`) 输出运行 makefile 之前和之后的信息。`--no-print-directory` 可以禁止 `-w`\n`-W <file>`   | `--what-if=<file>`, `--new-file=<file>`, `--assume-file=<file>` 假定目标 \\<file> 需要更新，如果和 `-n` 选项使用，那么这个参数会输出该目标更新时的运行动作\n`--warn-undefined-variables` | 只要 make 发现有未定义的变量，那么就输出警告信息\n<!--rehype:className=left-align-->"
    },
    {
      "id": "s4-83",
      "sectionId": "s4",
      "title": "`-debug[=<options>]`",
      "body": "输出 make 的调试信息。下面是 \\<options>的取值：\n\noptions  | :-\n:-       | :-\n`a` | `all`，输出所有的调试信息\n`b` | `basic`，只输出简单的调试信息。即输出不需要重编译的目标\n`v` | `verbose`，包括 b 的信息。输出包括 makefile 被解析的信息，不需要被重编译的依赖文件等\n`i` | `implicit`，输出所有的隐含规则\n`j` | `jobs`，输出执行规则中命令的详细信息，如命令的 PID、返回码等\n`m` | `makefile`，输出 make 读取 makefile，更新 makefile，执行 makefile 的信息\n<!--rehype:className=left-align-->"
    },
    {
      "id": "s4-85",
      "sectionId": "s4",
      "title": "make 的退出码",
      "body": ":-  | :-\n:-  | :-\n`0` | 成功执行\n`1` | 运行时出现错误\n`2` | 使用了 `-q` 选项，并且一些目标不需要更新"
    },
    {
      "id": "s5-86",
      "sectionId": "s5",
      "title": "单分支条件判断",
      "body": "• `ifeq` 的意思表示条件语句的开始，表达式包含两个参数，如果相同则为真。\n• `ifneq` 的意思表示条件语句的开始，表达式包含两个参数，如果不同则为真。\n• `else` 表示条件表达式为假的情况。\n• `endif` 表示一个条件语句的结束，任何一个条件表达式都应该以 `endif` 结束。\n\n```makefile\nrun:\nifeq ($(CC), cc)\n\t$(CC) -o foo foo.c\nelse\n\t$(CC) -o bar bar.c\nendif\n```"
    },
    {
      "id": "s5-88",
      "sectionId": "s5",
      "title": "%E5%A4%9A%E5%88%86%E6%94%AF%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%20-%20ifneq%20%E8%AF%AD%E6%B3%95",
      "body": "%60%60%60makefile%0Aifneq%20(%3Carg1%3E%2C%20%3Carg2%3E)%0Aifneq%20'%3Carg1%3E'%20'%3Carg2%3E'%0Aifneq%20%22%3Carg1%3E%22%20%22%3Carg2%3E%22%0Aifneq%20%22%3Carg1%3E%22%20'%3Carg2%3E'%0Aifneq%20'%3Carg1%3E'%20%22%3Carg2%3E%22%0A%60%60%60",
      "encoded": true
    },
    {
      "id": "s5-89",
      "sectionId": "s5",
      "title": "ifeq%20%E8%AF%AD%E6%B3%95",
      "body": "%60%60%60makefile%0Aifeq%20(%3Carg1%3E%2C%20%3Carg2%3E)%0Aifeq%20'%3Carg1%3E'%20'%3Carg2%3E'%0Aifeq%20%22%3Carg1%3E%22%20%22%3Carg2%3E%22%0Aifeq%20%22%3Carg1%3E%22%20'%3Carg2%3E'%0Aifeq%20'%3Carg1%3E'%20%22%3Carg2%3E%22%0A%60%60%60",
      "encoded": true
    },
    {
      "id": "s5-90",
      "sectionId": "s5",
      "title": "ifdef",
      "body": "```makefile\nifdef <variable-name>\n```\n\n`ifdef` 会根据 variable-name 判断，如果为空则为真\n\n```makefile\nbar =\nfoo = $(bar)\nifdef foo\n    frobozz = yes\nelse\n    frobozz = no\nendif\n\nrun:\n\techo $(frobozz)\n```\n\n`ifndef` 则和 `ifdef` 是相反的意思"
    },
    {
      "id": "s5-94",
      "sectionId": "s5",
      "title": "for 循环",
      "body": "```makefile\nLIST = one two three\nall:\n\tfor i in $(LIST); do \\\n\t    echo $$i; \\\n\tdone\n```"
    },
    {
      "id": "s6-95",
      "sectionId": "s6",
      "title": "字符串处理函数 - 替换函数(`subst`)",
      "body": "把字串 \\<text> 中的 \\<from> 字符串替换成 \\<to> 。\n\n```makefile\n$(subst <from>,<to>,<text>)\n```\n\n示例\n\n```makefile\n$(subst ee,EE,feet on the street)\n```"
    },
    {
      "id": "s6-99",
      "sectionId": "s6",
      "title": "字符串处理函数 - 模式字符串替换函数(`patsubst`)",
      "body": "查找 \\<text> 中的单词（**单词以空格、Tab或回车换行分隔**）是否符合模式 \\<pattern>。匹配，则以 \\<replacement> 替换。\n\n```makefile\n$(patsubst <pattern>,<replacement>,<text>)\n```\n\n• 示例\n\n```makefile\n$(patsubst %.c,%.o,x.c.c bar.c)\n```\n\n把字串 x.c.c bar.c 符合模式 %.c 的单词替换成 %.o ，返回结果是 x.c.o bar.o"
    },
    {
      "id": "s6-104",
      "sectionId": "s6",
      "title": "字符串处理函数 - 去空格函数(`strip`)",
      "body": "去掉 <string> 字串中开头和结尾的空字符。\n\n```makefile\n$(strip <string>)\n```\n\n示例\n\n```makefile\n$(strip a b c )\n```\n\n把字串 `a b c` 去掉开头和结尾的空格，结果是 a b c。"
    },
    {
      "id": "s6-109",
      "sectionId": "s6",
      "title": "字符串处理函数 - 查找字符串函数(`findstring`)",
      "body": "在字串 \\<in> 中查找 \\<find> 字串。\n\n```makefile\n$(findstring <find>,<in>)\n```\n\n示例：\n\n```makefile\n$(findstring a,a b c)\n$(findstring a,b c)\n```\n\n第一个函数返回 a 字符串，第二个返回空字符串"
    },
    {
      "id": "s6-114",
      "sectionId": "s6",
      "title": "字符串处理函数 - 过滤函数(`filter`)",
      "body": "以 \\<pattern> 模式过滤 \\<text> 字符串中的单词，保留符合模式 \\<pattern> 的单词。可以有多个模式。\n\n```makefile\n$(filter <pattern...>,<text>)\n```\n\n示例\n\n```makefile\nsources := foo.c bar.c baz.s ugh.h\nfoo: $(sources)\n    cc $(filter %.c %.s,$(sources)) -o foo\n$(filter %.c %.s,$(sources)) \n# 返回的值是 foo.c bar.c baz.s\n```"
    },
    {
      "id": "s6-118",
      "sectionId": "s6",
      "title": "字符串处理函数 - 反过滤函数(`filter-out`)",
      "body": "以 \\<pattern> 模式过滤 \\<text> 字符串中的单词，去除符合模式 \\<pattern> 的单词。可以有多个模式。\n\n```makefile\n$(filter-out <pattern...>,<text>)\n```\n\n示例：\n\n```makefile\nobjects=main1.o foo.o main2.o bar.o\nmains=main1.o main2.o\n$(filter-out $(mains),$(objects)) \n# 返回值是 foo.o bar.o 。\n```"
    },
    {
      "id": "s6-122",
      "sectionId": "s6",
      "title": "字符串处理函数 - 排序函数(`sort`)",
      "body": "给字符串 \\<list> 中的单词排序（升序）。\n\n```makefile\n$(sort <list>)\n```\n\n• 示例：`$(sort foo bar lose)` 返回 `bar foo lose`\n• 注意：sort 函数会去掉 `<list>` 中相同的单词"
    },
    {
      "id": "s6-125",
      "sectionId": "s6",
      "title": "字符串处理函数 - 取单词函数（`word`)",
      "body": "取字符串 \\<text> 中第 \\<n> 个单词。（从一开始）\n\n```makefile\n$(word <n>,<text>)\n```\n\n示例：`$(word 2, foo bar baz)` 返回值是 `bar`"
    },
    {
      "id": "s6-128",
      "sectionId": "s6",
      "title": "字符串处理函数 - 取单词串函数(`wordlist`)",
      "body": "• 从字符串 \\<text> 中取从 \\<s> 开始到 \\<e> 的单词串。\\<s> 和 \\<e> 是一个数字。\n\n```makefile\n$(wordlist <ss>,<e>,<text>)\n```\n\n示例：`$(wordlist 2, 3, foo bar baz)` 返回值是 bar baz。"
    },
    {
      "id": "s6-131",
      "sectionId": "s6",
      "title": "字符串处理函数 - 单词个数统计函数(`words`)",
      "body": "• 统计 \\<text> 中字符串中的单词个数。\n\n```makefile\n$(words <text>)\n```\n\n• 示例：`$(words, foo bar baz)` 返回值是 3。"
    },
    {
      "id": "s6-134",
      "sectionId": "s6",
      "title": "字符串处理函数 - 首单词函数(`firstword`)",
      "body": "• 取字符串 \\<text> 中的第一个单词。\n\n```makefile\n$(firstword <text>)\n```\n\n• 示例：`$(firstword foo bar)` 返回值是 `foo`"
    },
    {
      "id": "s6-137",
      "sectionId": "s6",
      "title": "文件名操作函数 - 取目录函数(`dir`)",
      "body": "从文件名序列 \\<names> 中取出目录部分。目录部分是指最后一个反斜杠（`/`）之前的部分。如果没有反斜杠，那么返回 `./`。\n\n```makefile\n$(dir <names...>)\n```\n\n```makefile\n$(dir src/foo.c hacks) \n#返回值是 src/ ./\n```"
    },
    {
      "id": "s6-139",
      "sectionId": "s6",
      "title": "取文件函数(`notdir`)",
      "body": "从文件名序列 \\<names> 中取出非目录部分。非目录部分是指最後一个反斜杠（`/`）之后的部分。\n\n```makefile\n$(notdir <names...>)\n```\n\n```makefile\n$(notdir src/foo.c hacks)\n# 返回值是 foo.c hacks\n```"
    },
    {
      "id": "s6-141",
      "sectionId": "s6",
      "title": "取后缀函数（`suffix`)",
      "body": "从文件名序列 \\<names> 中取出各个文件名的后缀\n\n```makefile\n$(suffix <names...>)\n```\n\n```makefile\n$(suffix src/foo.c src-1.0/bar.c hacks)\n# 返回值是 .c .c\n```"
    },
    {
      "id": "s6-143",
      "sectionId": "s6",
      "title": "取前缀函数(`basename`)",
      "body": "从文件名序列 \\<names> 中取出各个文件名的前缀部分。\n\n```makefile\n$(basename <names...>)\n```\n\n```makefile\n$(basename src/foo.c src-1.0/bar.c hacks) \n# 返回值是 src/foo src-1.0/bar hacks\n```"
    },
    {
      "id": "s6-145",
      "sectionId": "s6",
      "title": "加后缀函数(`addsuffix`)",
      "body": "把后缀 \\<suffix> 加到 \\<names> 中的每个单词后面\n\n```makefile\n$(addsuffix <suffix>,<names...>)\n```\n\n```makefile\n$(addsuffix .c,foo bar)\n# 返回值是 foo.c bar.c \n```"
    },
    {
      "id": "s6-147",
      "sectionId": "s6",
      "title": "加前缀函数(`addprefix`)",
      "body": "把前缀 \\<prefix> 加到 \\<names> 中的每个单词前面。\n\n```makefile\n$(addprefix <prefix>,<names...>)\n```\n\n```makefile\n$(addprefix src/,foo bar)\n# 返回值是 src/foo src/bar 。\n```"
    },
    {
      "id": "s6-149",
      "sectionId": "s6",
      "title": "连接函数(`join`)",
      "body": "把 \\<list2> 中的单词对应地加到 \\<list1> 的单词后面。\n\n```makefile\n$(join <list1>,<list2>)\n```\n\n```makefile\n$(join aaa bbb , 111 222 333)\n# 返回值是 aaa111 bbb222 333 。\n```"
    },
    {
      "id": "s6-151",
      "sectionId": "s6",
      "title": "其它函数 - foreach 函数",
      "body": "```makefile\n$(foreach <var>,<list>,<text>)\n```\n\n```makefile\n# $(name) 中的单词会被挨个取出，并存到变量 n 中，\n# $(n).o 每次根据 $(n) 计算出一个值，这些值以空格分隔，最后作为 foreach 函数的返回\nnames := a b c d\nfiles := $(foreach n,$(names),$(n).o)\nrun:\n\techo $(files)\n```"
    },
    {
      "id": "s6-152",
      "sectionId": "s6",
      "title": "if 函数",
      "body": "与之前的条件语句——`ifeq` 类似\n\n```makefile\n$(if <condition>,<then-part>)\n# 或者\n$(if <condition>,<then-part>,<else-part>)\n```"
    },
    {
      "id": "s6-154",
      "sectionId": "s6",
      "title": "call 函数",
      "body": "call 函数是唯一一个可以用来创建新的参数化的函数。\n\n```makefile\n$(call <expression>,<parm1>,<parm2>,...,<parmn>)\n```\n\n```makefile\nreverse =  $(2) $(1)\n\nfoo = $(call reverse,a,b)\n\nrun:\n\techo $(foo)\n# b a\n```"
    },
    {
      "id": "s6-156",
      "sectionId": "s6",
      "title": "shell 函数",
      "body": "使用操作系统 Shell 的命令\n\n```makefile\ncontents := $(shell cat foo)\nfiles := $(shell echo *.c)\n```"
    },
    {
      "id": "s6-158",
      "sectionId": "s6",
      "title": "控制 make 的函数",
      "body": "```makefile\n$(error <text ...>)\n# and\n$(warning <text ...>)\n```"
    },
    {
      "id": "s6-159",
      "sectionId": "s6",
      "title": "origin 函数",
      "body": "```makefile\n$(origin <variable>)\n```\n\norigin 函数用于告诉这个变量的从何而来\n\n:-              | :-\n:-              | :-\n`undefined`     | 如果 \\<variable> 未定义，返回 `undefined`\n`default`       | 如果 \\<variable> 是默认的，如 `CC`\n`environment`   | 如果 \\<variable> 是环境变量，并且当 Makefile 执行时，-e 参数没有被打开\n`file`          | 如果 \\<variable> 这个变量被定义在 Makefile 中。\n`command line`  | 如果 \\<variable> 这个变量是被命令行定义的。\n`override`      | 如果 \\<variable> 是被 override 指示符重新定义的。\n`automatic`     | 如果 \\<variable> 是一个命令运行中的自动化变量\n<!--rehype:className=left-align-->"
    },
    {
      "id": "s7-162",
      "sectionId": "s7",
      "title": "另见",
      "body": "• [make 中文教程](https://seisman.github.io/how-to-write-makefile/overview.html) _(seisman.github.io)_\n• [make 手册](https://www.gnu.org/software/make/manual/make.html#toc-Overview-of-make) _(<www.gnu.org>)_\n• [make 官网](https://www.gnu.org/software/make/) _<www.gnu.org>_"
    }
  ],
  "source": {
    "repo": "https://github.com/jaywcjlove/reference",
    "path": "docs/make.md",
    "ref": "main",
    "url": "https://github.com/jaywcjlove/reference/tree/main/docs/make.md",
    "lang": "zh",
    "mode": "local"
  }
}